### INTRODUCTION TO ELLIPTIC CURVE CRYPTOGRAPHY

#### OLGA SHEVCHUK

Abstract. In this paper, the mathematics behind the most famous cryptographic systems is introduced. These systems are compared in terms of security, efficiency and difficulty of implementation. Emphasis is given to elliptic curve cryptography methods which make use of more advanced mathematical concepts.

### Contents

| 1.<br>Introduction                                 | 1  |
|----------------------------------------------------|----|
| 2.<br>Public-key Cryptography Systems Overview     | 2  |
| 2.1.<br>Preliminaries                              | 2  |
| 2.2.<br>Discrete Logarithm Problem                 | 3  |
| 2.3.<br>Diffie-Hellman Key Exchange                | 3  |
| 2.4.<br>Other Public Cryptosystems                 | 4  |
| 3.<br>Elliptic Curve Cryptography                  | 5  |
| 3.1.<br>Elliptic Curve Fundamentals                | 5  |
| 3.2.<br>Elliptic Curves over the Reals             | 5  |
| 3.3.<br>Elliptic Curves over Finite Fields         | 8  |
| 3.4.<br>Computing Large Multiples of a Point       | 9  |
| 3.5.<br>Elliptic Curve Discrete Logarithm Problem  | 10 |
| 3.6.<br>Elliptic Curve Diffie-Hellman (ECDH)       | 10 |
| 3.7.<br>ElGamal System on Elliptic Curves          | 11 |
| 3.8.<br>Elliptic Curve Digital Signature Algorithm | 11 |
| 3.9.<br>Attacks on ECC and Pollard's rho algorithm | 12 |
| 3.10.<br>Future of ECC                             | 13 |
| Acknowledgments                                    |    |
| 4.<br>Bibliography                                 | 13 |
| References                                         |    |

# 1. Introduction

<span id="page-0-0"></span>Until the 1970's, the encryption process was rather complicated and time-consuming because it required the two parties to meet in order to set up a shared secret key for secure communication. This was the idea behind symmetric ciphers which formed the basis of private cryptosystems. That did not cause many problems when the users of cryptography were mostly comprised of small groups of individuals that shared the system of keys which they distributed inside their military or diplomatic

Date: August 16th 2020.

#### 2 OLGA SHEVCHUK

organizations. The rise of computer network communication changed the average user of cryptography, and the need to make frequent transactions with different parties made private cryptography obsolete. A new kind of cryptography emerged, called asymmetric, or public - key cryptography, and involved the lengthy process of establishing the common shared key without the need to meet.

# 2. Public-key Cryptography Systems Overview

<span id="page-1-0"></span>Diffie-Hellman was one of the first public-key cryptosystems invented. Unlike traditional private (symmetric) cryptosystems, public cryptosystems rely on oneway (trapdoor) functions, functions that are not difficult to be computed but the inverse of which takes exponentially more time to derive without the decryption key. The key required to encrypt messages can be made publicly available since it is computationally impossible to decrypt a message using encryption key only. Diffie-Hellman key exchange is a hybrid cryptosystem which combines the ideas of public-key cryptography along with a symmetric cryptosystem to transmit hidden messages. Even though public-key cryptosystems are more convenient, the explanation behind the use of the mentioned approach is that asymmetric cryptosystems are based on difficult mathematical computations and thus may be much more inefficient than symmetric ones.

<span id="page-1-1"></span>2.1. Preliminaries. Before introducing the Diffie - Hellman key exchange, let's start with some concepts which will justify the use of this cryptographic method.

Definition 2.1. (Order of an element in a group). Let G be a finite abelian group, written multiplicatively. Let a be any element in G. The order of a is the order (number of elements) of the subgroup generated by a, denoted by hai which consists of all powers of a. In other words, the order of a is the minimum value of i where i > 0 such that a <sup>i</sup> = 1.

Definition 2.2. Let φ(n) denote the Euler totient function which counts the number of integers from 1 to n (inclusive) which are coprime to n.

Definition 2.3. An element g ∈ F ∗ q is called a generator of the group F ∗ q , written multiplicatively, if for every a ∈ F ∗ q , we have g <sup>k</sup> = a for some integer k. In other words, the powers of g produce all elements in F ∗ q . If q = p where p is a prime, a generator is called a primitive root modulo p.

The following theorem establishes the existence of at least one generator in every finite field, the fact that justifies the use of those in the Diffie-Hellman key exchange.

Theorem 2.4. Every finite field F<sup>q</sup> has a primitive element which is the generator of the multiplicatively written group of the field.

Proof. To show that there exists a generator in F ∗ q , we need to prove the existence of an element of order q − 1. Let a be an element of order r in the multiplicatively written group F ∗ q . Let hai denote a cyclic group generated by a:

$$\langle a \rangle = \{1, a, a^2, \dots, a^{r-1}\}$$

Every element in hai is of the form a k for some k. So (a k ) <sup>r</sup> = (a r ) <sup>k</sup> = 1 since a <sup>r</sup> = 1. Therefore, a <sup>k</sup> has order dividing r. It follows that a k is a root of X<sup>r</sup> − 1, a polynomial over F ∗ q . Then hai forms the subset of roots of X<sup>r</sup> − 1. Since the order of hai is r and X<sup>r</sup> − 1 has r roots, the number of elements in hai equals the number of roots of X<sup>r</sup> − 1. From the properties established before, the elements of hai are the roots of X<sup>r</sup> − 1. We know that a cyclic group of order n, Z/nZ has φ(n) generators where φ(n) is the Euler totient function. It follows that the generators correspond to the integers which are coprime to n. Then hai has φ(r) generators or elements of order r. Let R = {r1, ..., rm} denote the set of the orders of the elements in F ∗ q . There are φ(ri) elements of order r<sup>i</sup> for every i. Since F ∗ q has order q − 1, it follows from Lagrange's theorem that r<sup>i</sup> |(q − 1) for all i. Then q − 1 = |F ∗ q | = X ri∈R φ(ri). Let S be the set of all divisors of q − 1. In other words,

S = {r : r|(q −1)}. Then the Euler totient function satisfies the following property:

$$\sum\_{r \in S} \phi(r) = q - 1.$$

R is a subset of S because r<sup>i</sup> X |(q − 1) for all i. Then S = R ∪ (S \ R). We have that r∈S φ(r) = X r∈R φ(r)+ X r∈S\R φ(r). Since X r∈S φ(r) = X r∈R φ(r) = q−1, X r∈S\R φ(r) = 0. Since φ(r) > 0 for all r, it follows that S \ R is an empty set. Thus S = R. Since S is a set of elements dividing q − 1, q − 1 ∈ S. It follows that q − 1 is also in R, the set of orders of elements in F ∗ q . Therefore, there is an element of order q − 1 in F ∗ q . Thus there exists at least one generator in F ∗ q .

The proof of the case of the existence of the generator in the multiplicatively written group (Z/pZ) <sup>∗</sup> where p is a prime is quite similar.

<span id="page-2-0"></span>2.2. Discrete Logarithm Problem. The mathematics of the method behind Diffie-Hellman is based on the discrete logarithm problem. As was discussed before, public-key cryptography rests on the idea of one-way functions. One example could be an exponential function in a large finite field. It would not be a good candidate for a one-way function over the reals since it is not easier to compute x y rather than to get its inverse logxy. Working over the finite field like Fp, one can compute x y for large x rather quickly, for example using repeated-squaring method. However, if there is an element z = x y , computing y = logxz is way more difficult in the finite field. Because of the use of the finite field, this problem is called "discrete".

Definition 2.5. The discrete logarithm problem on the multiplicatively written group, (Z/pZ) ∗ is defined in the following way. Let x, z ∈ (Z/pZ) <sup>∗</sup> where z belongs to the cyclic subgroup generated by x. Find an integer y such that:

$$\begin{pmatrix} 2.6 \\ \end{pmatrix} \tag{2.6}$$

<span id="page-2-1"></span>2.3. Diffie-Hellman Key Exchange. Let's suppose Alice and Bob have never met before. Diffie-Hellman key exchange allows them to jointly establish a shared secret key over an insecure channel. The algorithm can be implemented in the multiplicatively written group of any finite field. In this example, we will consider the most common implementation in a group of a prime field, (Z/pZ) ∗ . It is important that g ∈ (Z/pZ) ∗ is a generator since we want to make sure the generated shared key at the end received from a power of g is any element of (Z/pZ) ∗ . Let's outline the process step by step:

(1) Alice and Bob agree on a prime modulus p and a generator g, which are publicly known;

#### 4 OLGA SHEVCHUK

- (2) Alice selects a private random number a such that 1 < a < p − 1 and calculates l = g <sup>a</sup> mod p sending the result publicly to Bob;
- (3) Then Bob selects his private random number b such that 1 < b < p − 1 and calculates m = g <sup>b</sup> mod p sending the result publicly to Alice;
- (4) Alice takes Bob's public result m and raises it to the power of her private number obtaining m<sup>a</sup> mod p;
- (5) Bob takes Alice's public result l and raises it to the power of his private number obtaining l <sup>b</sup> mod p;
- (6) We notice that m<sup>a</sup> mod p = (g b ) <sup>a</sup> mod p = (g a ) <sup>b</sup> mod p = l <sup>b</sup> mod p = s is a shared key.

We note that only a and b are private knowledge, all the other values used during the exchange are publicly available. Therefore, the possible third party, Eve, will only have to work with g, l and m to obtain g ab mod p. However, it takes extremely long time to compute having only this knowledge. We note that if p is extremely large, then even the fastest world computers will be unable to find a such that g <sup>a</sup> ≡ l mod p given only l, p and g, a fact that restates the difficulty of discrete logarithm problem. Finally, it is important to mention that the use of the generator g in (Z/pZ) ∗ complicates the problem for Eve because the powers of g can be any element of the field, increasing the amount of possible choices for a key. Since the message can be arbitrarily large which may cause the slow asymmetric encryption process, the obtained secret shared key is used in the symmetric encryption which allows Bob and Alice to send messages across the same open communications channel. Then the regular version of ElGamal scheme is used to encrypt the symmetric key which is rather small compared to the message.

<span id="page-3-0"></span>2.4. Other Public Cryptosystems. RSA is another public-key cryptosystem introduced just after Diffie-Hellman key exchange. The security of RSA is guaranteed by two mathematical problems: an integer factorization problem and an RSA problem which is conjectured to be equally difficult.

Definition 2.7. The integer factorization problem can be stated as follows. Given a number N = pq, where p and q are large primes, find p and q.

Definition 2.8. The RSA problem is stated as follows. Find m such that c ≡ m<sup>e</sup> (mod n) where (n, e) is an RSA public key and c is an RSA ciphertext.

We can see that both cases use the concept of trapdoor function where the computation is easy to process in one direction but difficult to reverse.

Unlike Diffie-Hellman, RSA involves the use of two different keys (public and private) at each side where one is used for encryption and the other one - for decryption. The main improvement that RSA has over Diffie-Hellman key exchange is that it provides signatures generated using hash functions which not only verify that the message was actually from a specific sender but also help to make sure that its contents were not tampered with by a third party. This property of RSA is especially important since anyone can use the recipient's public key to send him encrypted messages. The idea behind this feature is that it is computationally impossible to find the same output for multiple inputs in the hash function, and the third party would not be able to change the content of the message without having the hash value changed. Among the disadvantages of RSA is that this cryptosystem may not be a sustainable solution for low-powered devices such as mobile

phones on which a lot of cryptography is done these days. Multiplying two prime numbers can take way more time than expected on such devices, and as a result, the trapdoor function may get less reliable (the gap between the difficulties of doing computations in both directions shrinks) in the long term. Security can be maintained by increasing the key sizes, but in that case efficiency is largely compromised. Thus, there arises a need in a public-key system based on the convenient trapdoor function, the one providing a better balance between security and efficiency.

# 3. Elliptic Curve Cryptography

<span id="page-4-0"></span>Researchers spent quite a lot of time trying to explore cryptographic systems based on more reliable trapdoor functions and in 1985 succeeded by discovering a new method, namely the one based on elliptic curves which were proposed to be the basis of the group for the discrete logarithm problem. Researchers believe that elliptic curves guarantee more security and provide with much smaller key sizes than other groups. For better understanding of the extent, let us use the visualization that compares the amount of energy one needs to break a cryptographic system with how much water that energy could boil. For example, a 228 - bit RSA key can be broken using less energy than that required to boil a teaspoon of water. However, one can equate the amount of energy needed to break a 228 - bit elliptic curve key with the energy used to boil all water on earth. A much longer RSA key of around 2,380 bits is needed for the same level of security which is rather inefficient. Let us dive deeper into what constitutes the mathematics behind this concept of elliptic curves.

### <span id="page-4-1"></span>3.1. Elliptic Curve Fundamentals.

Definition 3.1. An elliptic curve E over a field K is a cubic curve that consists of the points (x, y) satisfying the equation

<span id="page-4-3"></span>
$$(3.2)\tag{3.2}$$

$$y^2 = x^3 + ax + b$$

together with an element O called "the point at infinity".

It is important to note that [\(3.2\)](#page-4-3) is in the simplified Weierstrass form and holds only for fields in which the characteristic is not equal to 2 or 3. The requirements that the discriminant ∆ = −16(4a <sup>3</sup>+27b 2 ) is nonzero and the polynomial x <sup>3</sup>+ax+b has distinct roots ensure the curve's non-singularity.

<span id="page-4-2"></span>3.2. Elliptic Curves over the Reals. First, to get the general idea of how operations over elliptic curves work, we define the properties of elliptic curves over real numbers. The field of real numbers is used to get a clearer idea of the visual representations of the curves and understand how the geometry of the points on the curves works. An elliptic curve over the reals is defined by [\(3.2\)](#page-4-3) where a and b are real numbers. The graph of the elliptic curve over real numbers consists of two components if its discriminant is positive and of one component if it is negative. We now define the group law on elliptic curves which is useful for cryptographic purposes. In this paper, we will use the geometric approach to introduce the group law. Let's suppose that O is a "point at infinity" and that all the vertical lines in the space where our elliptic curve exists go through this point. Let E be an elliptic curve and let P and Q be two points on E. The addition of the points on the curve is best illustrated by the following composition law. We will use ⊕ to denote the composition of two points.

Definition 3.3. If P, Q ∈ E and L is the line through Q and P (if P = Q, L is the line tangent to E at P) which intersects the curve at the third point R, then the line L 0 through O and R intersects E at the third point which we denote P ⊕ Q. Thus P ⊕ Q is the point we get as a result of adding points P and Q on the curve.

The above law can be visualized on the elliptic curve in R (see Fig. 1, 2).

![](_page_5_Figure_3.jpeg)

We now claim that the points on the elliptic curve form an abelian group. This can be derived from the properties of the composition law.

Proposition 3.4. Let P, Q, R be three points (not necessarily distinct) lying on the intersection of E and a line L. Then the composition law has the following properties:

- (P ⊕ Q) ⊕ R = O.
- P ⊕ O = P for all P ∈ E.
- If P ∈ E, then there is a point P ∈ E such that P ⊕ ( P) = O.
- (P ⊕ Q) ⊕ R = P ⊕ (Q ⊕ R).

The above properties together with a closure property make E into abelian group.

- Proof. (1) By the composition law, P ⊕ Q is the point we get as a result of adding points P and Q on E. Let L <sup>0</sup> be the line through O, R and P ⊕ R. By B´ezout's Theorem, any line intersects the elliptic curve at three points counting multiplicity. Then the point we get as a result of adding P ⊕ Q and R is the third point of intersection of the line tangent to E at O with E. Let S be that point. Then for any collinear choice of P, Q and R, (P ⊕ Q) ⊕ R = S. In particular, we have that (O ⊕ O) ⊕ O = S. By working through the construction of addition, O ⊕ O = O. Therefore, S = O. This means that the third point of intersection of the line tangent to E at O is O, and thus, (P ⊕ Q) ⊕ R = O.
	- (2) If we let Q = O in the composition law and since every line is defined by two points, it can be seen that L = L 0 . Since L goes through the points P, O and R and L 0 - through O, R and P ⊕ O, P ⊕ O = P. Then O is the additive identity of E.
	- (3) Since P and Q both lie on L, we will end up at the same point irrespective of whether we add P and Q or Q and P. Thus, P ⊕ Q = Q ⊕ P.
- (4) Let the line L <sup>00</sup> intersect E at P, O and R. Then, by properties (1) and (2), (P ⊕ O) ⊕ R = O = P ⊕ R. This proves that there exists a point Q = P which is the additive inverse of P ∈ E.
- (5) The proof of the associativity of the points on E applies only to the generic case but, nevertheless, gives a good idea of why the property holds. First, we assume that P, Q and R are on the elliptic curve E over a field K with a distinguished point O. Moreover, we assume that P, Q and R are in "general position" which means that they have no special relations. In this case, this means that all the 8 points we construct below are distinct. By B´ezout's Theorem and the property (1) of the composition law, the line m<sup>0</sup> through Q and R intersects E at the third point −(Q ⊕ R) and the line n<sup>0</sup> through P and Q intersects E at −(P ⊕ Q). Following the same argument, the line m<sup>2</sup> through O and −(P ⊕Q) intersects E at P ⊕Q and the line n<sup>2</sup> through O and −(Q ⊕ R) intersects E at Q ⊕ R. Let S be the third point of intersection of the line n<sup>1</sup> through R and P ⊕Q with E and let T be the third point of intersection of the line m<sup>1</sup> through P and Q ⊕ R with E. As a result of the operations above, we get the diagram that looks like the one below.

![](_page_6_Figure_3.jpeg)

We assume that S 6= P ⊕ Q, S 6= R, T 6= Q ⊕ R, T 6= P. Following our previous construction method, S = −((P ⊕Q)⊕R) and T = −(P ⊕(Q⊕R)). To prove that (P ⊕ Q) ⊕ R = P ⊕ (Q ⊕ R), we can just show that S = T. We will suppose that S 6= T and derive a contradiction. Let V be the set of all homogeneous polynomials in x, y and z of degree 3. Then V is a vector space over K. V has dimension 10 since there are 10 monomials in x, y, z of degree 3 which form a basis of V . Each of the six lines we constructed above can be represented by homogeneous polynomial of degree 1 in a projective space. Let g(x, y, z) = n0n1n<sup>2</sup> and h(x, y, z) = m0m1m2. Since m0m1m<sup>2</sup> and n0n1n<sup>2</sup> are homogeneous polynomials of degree 1, g and h are homogeneous polynomials of degree 3. So g, h ∈ V . We will construct a new basis of V containing g and h. For convenience, we will rename the eight points P, Q, R, P ⊕ Q, −(P ⊕ Q), Q ⊕ R, −(Q ⊕ R), O as X0, ..., X7. For i ≥ 0, let's construct a homogeneous polynomial φ<sup>i</sup> of degree 3 such that φi(X<sup>j</sup> ) = 0 if i 6= j and φi(Xi) 6= 0. This polynomial can be obtained by multiplying any three of the lines m0, ..., m2, n0, ..., n<sup>2</sup> such that X<sup>i</sup> does not lie on any of the three chosen lines and X<sup>j</sup> lies on one of them. For 0 ≤ i < 8, let

<span id="page-6-0"></span>
$$\text{(3.5)}\qquad\qquad\mathcal{B}\_{i} = \{g, h\} \cup \{\phi\_{j}(X\_{j}) : 0 \le j < i\}.\tag{3.6}$$

#### 8 OLGA SHEVCHUK

We claim that B<sup>8</sup> is a basis of V . First, we will show that {g, h} is linearly independent. We observe that g(S) = n0(S)n1(S)n2(S) = 0. Since we claimed that S 6= T and by B´ezout's Theorem, S cannot lie on any of the lines m1, ..., m2. So h(S) = m0(S)m1(S)m2(S) 6= 0. Similarly, h(T) = 0 and g(T) 6= 0. Therefore, g and h are not multiples of each other. We observe that for every i such that ϕ ∈ B(i), ϕ(Xi) 6= 0. Then φ<sup>i</sup> ∈/ span B<sup>i</sup> because φi(Xi) 6= 0. Therefore, dim span Bi+1 = dim span B<sup>i</sup> + 1. From our construction of the basis in [\(3.5\)](#page-6-0), dim span B<sup>0</sup> = 2. Hence dim span B<sup>8</sup> = dim span B<sup>0</sup> + 8 = 10. Thus B is a basis of V . Suppose our elliptic curve E is represented by the Weierstrass equation of the form F(x, y) = 0. The curve is represented in the projective space by a smooth homogeneous polynomial f(x : y : z) = z <sup>3</sup>F(x/z, y/z) of degree 3. In particular, f ∈ V . Thus, we can write f as a linear combination of the elements of the basis B8:

$$f = ag + bh + \sum\_{i=0}^{7} c\_i \phi\_i.$$

By construction, we have that f(Xi) = ciφi(Xi) for each i. However, f(Xi) = 0 for all i since X0, ..., X<sup>7</sup> lie on E. Since φi(Xi) 6= 0, it follows that c<sup>i</sup> = 0 for all i and so f = ag + bh. Similarly, we see that

$$\begin{aligned} 0 &= f(S) = ag(S) + bh(S) \\ 0 &= f(T) = ag(T) + bh(T). \end{aligned}$$

Since g(S) = h(T) = 0 and h(S) 6= 0, g(T) 6= 0, it follows that a = b = 0. Hence, we conclude that f = 0 which is a contradiction since we defined f to be a polynomial of degree 3. Thus, our supposition was wrong and S = T which means (P ⊕ Q) ⊕ R = P ⊕ (Q ⊕ R).

$$\mathbb{D}$$

In addition to the properties above, the points on the elliptic curve satisfy the closure property or in other words, if P, Q ∈ E, then P ⊕ Q ∈ E. This can be verified by the composition law we defined before. Thus, we conclude that the points on the elliptic curve form an abelian group.

<span id="page-7-0"></span>3.3. Elliptic Curves over Finite Fields. Let K = F<sup>q</sup> be the finite field where q = p <sup>r</sup> and E be an elliptic curve defined over K. An elliptic curve over F<sup>q</sup> is defined by [\(3.2\)](#page-4-3) where a, b ∈ Fq. The graph of elliptic curve over a finite field does not look as neat as the one over R: usually, it is just a discrete set of points. Nevertheless, the set of points E(Fq) still forms a finite abelian group in F<sup>q</sup> which is either cyclic or a product of two cyclic groups. A group forms a finite number of points, a feature that enables precise arithmetic to be performed with faster calculations and lower probability of a round-off error. For example, the field F<sup>p</sup> is widely used in practice mostly because of the convenience of mathematical operations used in it. All the values produced by operations on the points within a field are reduced modulo p and result in another points within the same field. Besides, every integer has a multiplicative inverse modulo p which is convenient for division in the field. An important information regarding elliptic curves over finite fields is the number of rational points it forms. The value of the number of points is essential for determining the difficulty of solving the discrete logarithm problem in E(Fq) and ensures the security of the system which depends on that value having a large prime

factor. Since there are q choices for each x and for each choice of x, there are at most 2 choices for y in the equation that defines elliptic curves over the finite fields, E has at most 2q+ 1 F<sup>q</sup> points counting O, "the point at infinity". Hasse's theorem gives a more precise estimate of the number of points on E bounding the value both above and below: √

$$|\#E(F\_q) - (q+1)| \le 2\sqrt{q}.$$

It follows from the result that #E(Fq) grows approximately as q, the number of elements in the field. To get the exact number of points on the certain curve, Schoof's algorithm is widely used. It was the first polynomial-time algorithm in log q the running time of which was O(log<sup>8</sup> q). The approach makes use of the Hasse's theorem, Frobenius endomorphism φ, Chinese remainder theorem and division polynomials. For more details on this, see [\[7\]](#page-12-4).

<span id="page-8-0"></span>3.4. Computing Large Multiples of a Point. Let G denote the abelian group formed by the points on the elliptic curve E with a ⊕ operation we defined before. The multiplication by scalar t on E is defined by repeatedly adding the point P the amount of times that is the same as the value of the scalar:

$$tP = \underbrace{P \oplus P \oplus \dots \oplus P}\_{\bullet}$$

The multiple of P can be computed more efficiently rather than by just adding P to itself t times which takes linear time. This can be done by the double and add method. First of all, to compute tP, we start with the binary expansion of t:

$$t = t\_0 + 2t\_1 + 2^2t\_2 + \dots + 2^k t\_k,$$

where t0...t<sup>k</sup> ∈ {0, 1}. Then tP is computed as:

$$t = t\_0 P + 2t\_1 P + 2^2 t\_2 P + \dots + 2^k t\_k P,$$

where we can compute 2kP by k doublings and k = blog<sup>2</sup> (t)c. Assuming that on average, half of the terms in the expansion will be 0, tP can be computed with log<sup>2</sup> (t) doublings and <sup>1</sup> 2 log<sup>2</sup> (t) additions. Algorithm 1 extends the idea presented above.

Let i represent the bit of t and m - the number of digits in the binary representation of t.

|    | Algorithm 1 Double and Add      |                                            |  |
|----|---------------------------------|--------------------------------------------|--|
|    | 1: procedure doubleAndAdd(t, P) | . The product of t and P                   |  |
| 2: | result ← 0                      |                                            |  |
| 3: | m ← math.floor(log2(t)) + 1     |                                            |  |
| 4: | for i = 0 to m do               | . Iterating through the binary digits of t |  |
| 5: | if ti<br>= 1 then               |                                            |  |
| 6: | result ← result + P             |                                            |  |
| 7: | P ← 2 ∗ P                       |                                            |  |
| 8: | return result                   |                                            |  |

Since there are a total of m steps in the algorithm and at most 2 operations per step, the worst case scenario is that we would have to perform 2m operations. This algorithm speeds up the computation time to O(m) or equivalently O(log(t)) which is exponentially better than the linear algorithm mentioned before.

### <span id="page-9-0"></span>3.5. Elliptic Curve Discrete Logarithm Problem.

<span id="page-9-2"></span>Definition 3.6. Let E be an elliptic curve defined over a finite field and G - defined as before. If P ∈ G and R = kP is a multiple of P where k is a scalar, we define the discrete logarithm problem on E as follows. Find an integer k such that kP = R where P is a generator point on E and R belongs to the cyclic subgroup generated by P .

The double and add algorithm we described before proved that computing kP can be rather fast and efficient. However, discrete logarithm problem on E is said to be much harder to solve than discrete logarithm problem in the multiplicatively written group (Z/pZ) ∗ . The best known algorithms that can break discrete logarithm problem on elliptic curves have purely exponential runtime. This again supports the reliability of the trapdoor function that is the basis of elliptic curve cryptosystem.

<span id="page-9-1"></span>3.6. Elliptic Curve Diffie-Hellman (ECDH). The idea behind the exchange system is the same as the one behind the regular Diffie-Hellman: Alice and Bob want to communicate securely over an insecure channel without a need to meet each other. Let's consider the most common implementation in the prime field, Fp.

(1) Alice and Bob agree on a set of domain parameters such as (p, a, b, P, n, h) where p is a prime, a and b are random values that make up the equation of elliptic curve E, P is a random point on E, n is the order of P and h is a cofactor of the group G. Order n is usually a prime number and is the smallest possible integer such that nP = O. Then the cyclic subgroup of G generated by P is of the form:

$$
\langle P \rangle = \{ \mathcal{O}, P, 2P, 3P, \dots, (n-1)P \}.
$$

Since n is the order of P, it is the size of the subgroup generated by P. Thus it follows by Lagrange's Theorem that h·n = |G| where h is a cofactor and in this case, the number of disjoint cyclic subgroups formed by G. To make the discrete logarithm problem harder to solve, n should be a large number. On the other hand, h must be small (h ≤ 4), preferably h = 1. The derivation of domain parameters is not usually done by each participant because it is rather time-consuming. The reason for this is that the process may require the computation of |G| which is usually done by the involved Schoof's algorithm. That is why, several organizations publish recommended curves with computed parameters for participants to use. All the domain parameters are public knowledge.

- (2) Both Bob and Alice randomly choose a private key d from the interval [1, n − 1] and calculate the public key Q = dP. The point P is used as a generator. Then Alice's key pair is (dA, QA) and Bob's key pair is (dB, QB).
- (3) The parties exchange each other's public keys. Alice computes dAQ<sup>B</sup> using Bob's public key and Bob computes dBQ<sup>A</sup> using Alice's public key. The result calculated by both parties is equal since dAQ<sup>B</sup> = dAdBP = dBdAP = dBQ<sup>A</sup> and is thus a shared key. The shared secret is the x or y-coordinate of the computed point dAdBP. A third party Eve only has knowledge of P, Q<sup>A</sup> and Q<sup>B</sup> and will be unable to get the shared key without solving the discrete logarithm problem.

The obtained shared key can be used to encrypt the communication between parties using symmetric-key cipher. Alternatively, a fully asymmetric cryptosystem based on the elliptic curve analogue of the basic ElGamal encryption scheme can be used for message transmission, even though it is usually slower than the symmetric one. Therefore, just like in regular Diffie-Hellman key exchange, it is used more just for key encryption. We present it in the following section.

<span id="page-10-0"></span>3.7. ElGamal System on Elliptic Curves. Let p be a prime, E - a chosen elliptic curve over Fp, P - a randomly chosen point on E, and n - the order of P. Let Q be the public key of the intended recipient of the enciphered message generated in the same way as in Diffie-Hellman key exchange. Let m represent the plaintext.

First of all, a sender Alice comes up with a public fucntion f : m 7→ M which maps a message m to a point M on E. Then, she chooses a random value k such that k ∈<sup>R</sup> [1, n − 1] and computes C = kP. After that, she gets a point M on the curve by computing M = f(m). Finally, she computes D = M + kQ. The ciphertext she sends to Bob is represented as a set of points (C, D).

Then Bob uses his private key d to get a plaintext. He first computes M = D−dC and then performs m = f −1 (M).

We note that dC = d(kP) = k(dP) = kQ and it can be seen that a third party who wishes to receive a value of M, needs to compute kQ. Computing kQ given domain parameters kP and Q is the same discrete logarithm problem introduced as part of the Diffie-Hellman key exchange.

<span id="page-10-1"></span>3.8. Elliptic Curve Digital Signature Algorithm. Another advantage of elliptic curve cryptography is that just like RSA cryptosystem, it provides the opportunity for the parties to "sign" their messages so that the receiver knows exactly the message is from him. Let m be the message and n be the prime order of the subgroup generated by P.

Algorithm 2 Signature generation algorithm

|     | 1: procedure SigGen(m, n, P)                                                          |
|-----|---------------------------------------------------------------------------------------|
| 2:  | Compute e = hash(m).                                                                  |
| 3:  | z ← l leftmost bits of e where l is bit length of n.                                  |
| 4:  | Select k ∈R<br>[1, n − 1].                                                            |
| 5:  | Compute (x1, y1) = kP.                                                                |
| 6:  | Compute r = x1<br>mod n.                                                              |
| 7:  | if r = 0 then                                                                         |
| 8:  | Select a new k, back to step 4.                                                       |
| 9:  | −1<br>−1<br>Compute s = k<br>(z + rdA) mod n where dA<br>is Alice's private key and k |
|     | is the multiplicative inverse of k mod n.                                             |
| 10: | if s = 0 then                                                                         |
| 11: | Select a new k, back to step 4.                                                       |
| 12: | Return (r, s).<br>. the signature                                                     |

Then Bob can verify Alice's signature using Algorithm 3. He needs to obtain a copy of Alice's public key Q<sup>A</sup> to accomplish this task.

Even though ECC shows many great advantages mentioned before, one if its main drawbacks is that the domain parameters need to be computed in advance

Algorithm 3 Signature verification algorithm

|     | 1: procedure SigVer(E, n, QA, s, z, P, r)                                 |
|-----|---------------------------------------------------------------------------|
| 2:  | if QA<br>6= O and QA<br>∈ E and nQA<br>= O and r, s ∈R<br>[1, n − 1] then |
| 3:  | = zs−1 mod<br>Compute u1<br>n.                                            |
| 4:  | = rs−1 mod<br>Compute u2<br>n.                                            |
| 5:  | Compute the point (x1, y1) = u1P + u2QA.                                  |
| 6:  | if (x1, y1) 6= O and r ≡ x1<br>mod n then                                 |
| 7:  | "The signature is valid".                                                 |
| 8:  | else                                                                      |
| 9:  | "The signature is invalid".                                               |
| 10: | else                                                                      |
| 11: | "The signature is invalid".                                               |

and they are rather expensive to generate. Thus a thorough analysis of the curves must be done. In addition, just like any other cryptosystem, ECC may face danger by classical and quantum attacks some of which will be discussed in the next section.

<span id="page-11-0"></span>3.9. Attacks on ECC and Pollard's rho algorithm. Elliptic curve cryptography is subject to both classical and quantum attacks. Classical attacks are usually slow and require exponential running time to solve the elliptic curve discrete logarithm problem. Among quantum attacks, there are cases like Shor's algorithm which fulfills the attack in polynomial time. In this section, we will present the Pollard's rho-algorithm which is the fastest classical algorithm for solving ECDLP. Let E be the elliptic curve and the discrete logarithm problem on E be as defined in [\(3.6\)](#page-9-2). Let n be the order of the subgroup generated by P. The running time of the algorithm is roughly O( √ n). In addition, it requires just O(1) in space complexity which is the best result compared to other methods that solve the discrete logarithm problem. The idea behind the algorithm is to find distinct pairs of integers (aj<sup>1</sup> , bj<sup>1</sup> ) and (aj<sup>2</sup> , bj<sup>2</sup> ) such that aj<sup>1</sup> P + bj1Q = aj<sup>2</sup> P + bj2Q. This can be done by the most efficient algorithm for this purpose: Floyd's cycle finding algorithm. One needs to partition the set of points on E into three subsets of roughly the same size and apply a suitable iterating function f to them. The result of applying the function to each point will generate the sequence with terms of the form A<sup>i</sup> = ajP + bjQ. Once there is a match A<sup>i</sup><sup>1</sup> = A<sup>i</sup><sup>2</sup> , we get a<sup>j</sup><sup>1</sup> P + b<sup>j</sup>1Q = a<sup>j</sup><sup>2</sup> P + b<sup>j</sup>2Q. The match will be found eventually since the number of points on the curve is finite and the subgroup generated by P is cyclic. The birthday paradox ensures the high probability of that event. The path for finding a<sup>j</sup><sup>1</sup> , b<sup>j</sup><sup>1</sup> , a<sup>j</sup><sup>2</sup> , b<sup>j</sup><sup>2</sup> will consist of a loop with a tail attached to it which looks just like letter ρ. In the end, we compute k = (a<sup>j</sup><sup>1</sup> − a<sup>j</sup><sup>2</sup> )(b<sup>j</sup><sup>2</sup> − b<sup>j</sup><sup>1</sup> ) <sup>−</sup><sup>1</sup> mod n. According to research, the randomness of the function f and thus the performance of the algorithm can be improved by increasing the number of partitions of the set of points on E.

What concerns quantum attacks, Peter Shor in 1994 showed that because of their interesting property of computing over qubits, quantum computers can take polynomial time to factor large numbers or solve a discrete logarithm problem over a finite field. Scientists believe, that we will be able to use ECC more or less securely until quantum computers take over.

<span id="page-12-0"></span>3.10. Future of ECC. We have mentioned that Shor's algorithm could destroy the elliptic curve cryptography as it is. Even though quantum computers still exist mostly in theory, a lot of organizations are thinking of ways to prevent unexpected attacks by moving towards inventing quantum-resistant schemes. Even though the life of the traditional elliptic curve cryptography may come to an end, recently Diffie-Hellman key exchange based on isogenies of super singular elliptic curves was developed which may prove to be quantum-resistant. This may take elliptic curve cryptography to a new, post-quantum level. We will not concern ourselves here with the details of implementation but will make some definitions and notes:

- (1) The algorithm uses super singular curves over Fp<sup>2</sup> where p is a prime;
- (2) A supersingular curve is defined as having no points of order p;
- (3) An isogeny φ : E<sup>1</sup> → E<sup>2</sup> is a rational map such that the number of points on the two curves is the same.

The reason for the belief in success of the algorithm is that the set of isogenies forms a non-abelian group. That is why, it is resistant to Shor's attack which targets algorithms based on abelian groups. The isogeny-based exchange provides small keys which is rather efficient but lacks further research which would fully prove its security.

Among classical algorithms, there also exist some which are based on non-abelian groups and thus are conjectured to be resistant to quantum attacks. Some of those are: hash-based cryptography, lattice-based cryptography, multivariate equations, and error codes.

### <span id="page-12-1"></span>Acknowledgments

"I would like to thank Peter May for organizing the 2020 Apprentice Program despite the difficult circumstances. I would also like to thank all of the REU staff and faculty for keeping the program interesting throughout the whole time. In particular, I am especially thankful to my mentors Cindy Tan and Iris Li for meeting with me frequently throughout the process and helping me out with any questions I had."

# 4. Bibliography

## <span id="page-12-3"></span>References

- <span id="page-12-2"></span>[1] Canteaut, Anne. Chapter 1. Finite Fields. [https://www.rocq.inria.fr/secret/Anne.](https://www.rocq.inria.fr/secret/Anne.Canteaut/MPRI/ff.pdf) [Canteaut/MPRI/ff.pdf](https://www.rocq.inria.fr/secret/Anne.Canteaut/MPRI/ff.pdf)
- [2] Hankerson, Darrel; Menezes, Alfred; Vanstone, Scott. Guide to Elliptic Curve Cryptography. New York: Springer-Verlag. 2004. pdf.
- [3] Koblitz, Neal. A Course in number Theory and Cryptography. New York: Springer Verlag. 1994. pdf.
- [4] Silverman, Joseph H. An Introduction to the Theory of Elliptic Curves. [https://www.math.](https://www.math.brown.edu/~jhs/Presentations/WyomingEllipticCurve.pdf) [brown.edu/~jhs/Presentations/WyomingEllipticCurve.pdf](https://www.math.brown.edu/~jhs/Presentations/WyomingEllipticCurve.pdf)
- [5] Silverman, Joseph H. The Arithmetic of Elliptic Curves. Springer Science+Business Media, LLC 2009, 1986. pdf.
- [6] Sutherland, Andrew. 18.783 Elliptic Curves. Lecture 2: Elliptic curves as abelian groups. <https://math.mit.edu/classes/18.783/2015/LectureNotes2.pdf>
- <span id="page-12-4"></span>[7] Sutherland, Andrew. 18.783 Elliptic Curves. Lecture 9: Schoof' algorithm. [https://math.mit.](https://math.mit.edu/classes/18.783/2015/LectureNotes9.pdf) [edu/classes/18.783/2015/LectureNotes9.pdf](https://math.mit.edu/classes/18.783/2015/LectureNotes9.pdf)
- [8] Wohlwend, Jeremy. Elliptic Curve Cryptography: Pre and Post Quantum. [https://math.mit.](https://math.mit.edu/~apost/courses/18.204-2016/18.204_Jeremy_Wohlwend_final_paper.pdf) [edu/~apost/courses/18.204-2016/18.204\\_Jeremy\\_Wohlwend\\_final\\_paper.pdf](https://math.mit.edu/~apost/courses/18.204-2016/18.204_Jeremy_Wohlwend_final_paper.pdf)