## <span id="page-0-0"></span>ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER SHANGHAI VERSION efc5f9a – 2025-02-04

#### DR. GAVIN WOOD FOUNDER, ETHEREUM & PARITY GAVIN@PARITY.IO

Abstract. The blockchain paradigm when coupled with cryptographically-secured transactions has demonstrated its utility through a number of projects, with Bitcoin being one of the most notable ones. Each such project can be seen as a simple application on a decentralised, but singleton, compute resource. We can call this paradigm a transactional singleton machine with shared-state.

Ethereum implements this paradigm in a generalised manner. Furthermore it provides a plurality of such resources, each with a distinct state and operating code but able to interact through a message-passing framework with others. We discuss its design, implementation issues, the opportunities it provides and the future hurdles we envisage.

### 1. Introduction

With ubiquitous internet connections in most places of the world, global information transmission has become incredibly cheap. Technology-rooted movements like Bitcoin have demonstrated through the power of the default, consensus mechanisms, and voluntary respect of the social contract, that it is possible to use the internet to make a decentralised value-transfer system that can be shared across the world and virtually free to use. This system can be said to be a very specialised version of a cryptographically secure, transaction-based state machine. Follow-up systems such as Namecoin adapted this original "currency application" of the technology into other applications, albeit rather simplistic ones.

Ethereum is a project which attempts to build the generalised technology; technology on which all transactionbased state machine concepts may be built. Moreover it aims to provide to the end-developer a tightly integrated end-to-end system for building software on a hitherto unexplored compute paradigm in the mainstream: a trustful object messaging compute framework.

1.1. Driving Factors. There are many goals of this project; one key goal is to facilitate transactions between consenting individuals who would otherwise have no means to trust one another. This may be due to geographical separation, interfacing difficulty, or perhaps the incompatibility, incompetence, unwillingness, expense, uncertainty, inconvenience, or corruption of existing legal systems. By specifying a state-change system through a rich and unambiguous language, and furthermore architecting a system such that we can reasonably expect that an agreement will be thus enforced autonomously, we can provide a means to this end.

Dealings in this proposed system would have several attributes not often found in the real world. The incorruptibility of judgement, often difficult to find, comes naturally from a disinterested algorithmic interpreter. Transparency, or being able to see exactly how a state or judgement came about through the transaction log and rules or instructional codes, never happens perfectly in human-based systems since natural language is necessarily vague, information

is often lacking, and plain old prejudices are difficult to shake.

Overall, we wish to provide a system such that users can be guaranteed that no matter with which other individuals, systems or organisations they interact, they can do so with absolute confidence in the possible outcomes and how those outcomes might come about.

1.2. Previous Work. [Buterin \[2013\]](#page-17-0) first proposed the kernel of this work in late November, 2013. Though now evolved in many ways, the key functionality of a blockchain with a Turing-complete language and an effectively unlimited inter-transaction storage capability remains unchanged.

[Dwork and Naor \[1992\]](#page-17-1) provided the first work into the usage of a cryptographic proof of computational expenditure ("proof-of-work") as a means of transmitting a value signal over the Internet. The value-signal was utilised here as a spam deterrence mechanism rather than any kind of currency, but critically demonstrated the potential for a basic data channel to carry a strong economic signal, allowing a receiver to make a physical assertion without having to rely upon trust. [Back \[2002\]](#page-17-2) later produced a system in a similar vein.

The first example of utilising the proof-of-work as a strong economic signal to secure a currency was by [Vish](#page-18-0)[numurthy et al. \[2003\]](#page-18-0). In this instance, the token was used to keep peer-to-peer file trading in check, providing "consumers" with the ability to make micro-payments to "suppliers" for their services. The security model afforded by the proof-of-work was augmented with digital signatures and a ledger in order to ensure that the historical record couldn't be corrupted and that malicious actors could not spoof payment or unjustly complain about service delivery. Five years later, [Nakamoto \[2008\]](#page-18-1) introduced another such proof-of-work-secured value token, somewhat wider in scope. The fruits of this project, Bitcoin, became the first widely adopted global decentralised transaction ledger.

Other projects built on Bitcoin's success; the alt-coins introduced numerous other currencies through alteration to the protocol. Some of the best known are Litecoin and Primecoin, discussed by [Sprankel \[2013\]](#page-18-2). Other projects sought to take the core value content mechanism of the protocol and repurpose it; [Aron \[2012\]](#page-17-3) discusses, for example, the Namecoin project which aims to provide a decentralised name-resolution system.

Other projects still aim to build upon the Bitcoin network itself, leveraging the large amount of value placed in the system and the vast amount of computation that goes into the consensus mechanism. The Mastercoin project, first proposed by [Willett \[2013\]](#page-18-3), aims to build a richer protocol involving many additional high-level features on top of the Bitcoin protocol through utilisation of a number of auxiliary parts to the core protocol. The Coloured Coins project, proposed by [Rosenfeld et al. \[2012\]](#page-18-4), takes a similar but more simplified strategy, embellishing the rules of a transaction in order to break the fungibility of Bitcoin's base currency and allow the creation and tracking of tokens through a special "chroma-wallet"-protocol-aware piece of software.

Additional work has been done in the area with discarding the decentralisation foundation; Ripple, discussed by [Boutellier and Heinzen \[2014\]](#page-17-4), has sought to create a "federated" system for currency exchange, effectively creating a new financial clearing system. It has demonstrated that high efficiency gains can be made if the decentralisation premise is discarded.

Early work on smart contracts has been done by [Szabo](#page-18-5) [\[1997\]](#page-18-5) and [Miller \[1997\]](#page-18-6). Around the 1990s it became clear that algorithmic enforcement of agreements could become a significant force in human cooperation. Though no specific system was proposed to implement such a system, it was proposed that the future of law would be heavily affected by such systems. In this light, Ethereum may be seen as a general implementation of such a crypto-law system.

For a list of terms used in this paper, refer to Appendix [A.](#page-18-7)

### 2. The Blockchain Paradigm

Ethereum, taken as a whole, can be viewed as a transaction-based state machine: we begin with a genesis state and incrementally execute transactions to morph it into some current state. It is this current state which we accept as the canonical "version" of the world of Ethereum. The state can include such information as account balances, reputations, trust arrangements, data pertaining to information of the physical world; in short, anything that can currently be represented by a computer is admissible. Transactions thus represent a valid arc between two states; the 'valid' part is important—there exist far more invalid state changes than valid state changes. Invalid state changes might, e.g., be things such as reducing an account balance without an equal and opposite increase elsewhere. A valid state transition is one which comes about through a transaction. Formally:

<span id="page-1-0"></span>
$$\begin{array}{cc} \text{(1)} & \sigma\_{t+1} \equiv \Upsilon(\sigma\_t, T) \end{array}$$

where Υ is the Ethereum state transition function. In Ethereum, Υ, together with σ are considerably more powerful than any existing comparable system; Υ allows components to carry out arbitrary computation, while σ allows components to store arbitrary state between transactions.

Transactions are collated into blocks; blocks are chained together using a cryptographic hash as a means of reference. Blocks function as a journal, recording a series of

transactions together with the previous block and an identifier for the final state (though do not store the final state itself—that would be far too big).

Formally, we expand to:

$$\begin{array}{rcl}(2) & & \sigma\_{t+1} & \equiv & \Pi(\sigma\_t, B) \end{array}$$

$$\begin{array}{ccccc} \text{(3)} & & B & \equiv & \langle \ldots, (T\_0, T\_1, \ldots), \ldots \rangle \\ \end{array}$$

(4) Π(σ, B) ≡ [Υ\(](#page-1-0)Υ(σ, T0), T1)...

Where [B](#page-5-0) is this block, which includes a series of transactions amongst some other components and [Π](#page-16-0) is the block-level state-transition function for transactions[1](#page-1-1) .

This is the basis of the blockchain paradigm, a model that forms the backbone of not only Ethereum, but all decentralised consensus-based transaction systems to date.

2.1. Value. In order to incentivise computation within the network, there needs to be an agreed method for transmitting value. To address this issue, Ethereum has an intrinsic currency, Ether, known also as ETH and sometimes referred to by the Old English ¯D. The smallest subdenomination of Ether, and thus the one in which all integer values of the currency are counted, is the Wei. One Ether is defined as being 10<sup>18</sup> Wei. There exist other subdenominations of Ether:

| Multiplier | Name   |
|------------|--------|
| 100        | Wei    |
| 109        | Gwei   |
| 1012       | Szabo  |
| 1015       | Finney |
| 1018       | Ether  |

Throughout the present work, any reference to value, in the context of Ether, currency, a balance or a payment, should be assumed to be counted in Wei.

2.2. Which History? Since the system is decentralised and all parties have an opportunity to create a new block on some older pre-existing block, the resultant structure is necessarily a tree of blocks. In order to form a consensus as to which path, from root [\(the genesis block\)](#page-38-0) to leaf (the block containing the most recent transactions) through this tree structure, known as the blockchain, there must be an agreed-upon scheme. If there is ever a disagreement between nodes as to which root-to-leaf path down the block tree is the 'best' blockchain, then a fork occurs.

This would mean that past a given point in time (block), multiple states of the system may coexist: some nodes believing one block to contain the canonical transactions, other nodes believing some other block to be canonical, potentially containing radically different or incompatible transactions. This is to be avoided at all costs as the uncertainty that would ensue would likely kill all confidence in the entire system.

Since the Paris hard fork, reaching consensus on new blocks is managed by a protocol called the Beacon Chain. It is known as the consensus layer of Ethereum, and it defines the rules for determining the canonical history of Ethereum blocks. This document describes the execution layer of Ethereum. The execution layer defines the rules for interacting with and updating the state of the Ethereum virtual machine. The consensus layer is described in greater detail in the [consensus specifications.](https://github.com/ethereum/consensus-specs) How the consensus

<span id="page-1-1"></span><sup>1</sup>Note that since the Shanghai fork, blocks also needs to process withdrawal operations in order to reach their final state. Withdrawal operations are defined in sub-section [4.3,](#page-4-0) and block final state is discussed in greater detail in section [12.](#page-15-0)

layer is used to determine the canonical state of Ethereum is discussed in section [11.](#page-15-1)

There are many versions of Ethereum, as the protocol has undergone a number of updates. These updates can be specified to occur:

- at a particular block number in the case of pre-Paris updates,
- after reaching a terminal total difficulty in the case of the Paris update, or
- at a particular block timestamp in the case of post-Paris updates.

This document describes the Shanghai version.

In order to follow back the history of a path, one must reference multiple versions of this document. Here are the block numbers of protocol updates on the Ethereum main network:[2](#page-2-0)

| Name              | First Block Number |
|-------------------|--------------------|
| FHomestead        | 1150000            |
| FTangerineWhistle | 2463000            |
| FSpuriousDragon   | 2675000            |
| FByzantium        | 4370000            |
| FConstantinople   | 7280000            |
| FPetersburg       | 7280000            |
| FIstanbul         | 9069000            |
| FMuirGlacier      | 9200000            |
| FBerlin           | 12244000           |
| FLondon           | 12965000           |
| FArrowGlacier     | 13773000           |
| FGrayGlacier      | 15050000           |
| FParis            | 15537394           |
| FShanghai         | 17034870           |

Occasionally actors do not agree on a protocol change, and a permanent fork occurs. In order to distinguish between diverged blockchains, EIP-155 by [Buterin \[2016\]](#page-17-5) introduced the concept of chain ID, which we denote by β. For the Ethereum main network

(5) β = 1

### <span id="page-2-1"></span>3. Conventions

We use a number of typographical conventions for the formal notation, some of which are quite particular to the present work:

The two sets of highly structured, 'top-level', state values, are denoted with bold lowercase Greek letters. They fall into those of world-state, which are denoted σ (or a variant thereupon) and those of machine-state, µ.

Functions operating on highly structured values are denoted with an upper-case Greek letter, e.g. [Υ,](#page-1-0) the Ethereum state transition function.

For most functions, an uppercase letter is used, e.g. C, the general cost function. These may be subscripted to denote specialised variants, e.g. C[SSTORE](#page-34-0), the cost function for the [SSTORE](#page-34-1) operation. For specialised and possibly externally defined functions, we may format as typewriter text, e.g. the Keccak-256 hash function (as per version 3 of the winning entry to the SHA-3 contest by [Bertoni](#page-17-6) [et al. \[2011\]](#page-17-6), rather than the final SHA-3 specification), is

denoted KEC (and generally referred to as plain Keccak). Also, KEC512 refers to the Keccak-512 hash function.

Tuples are typically denoted with an upper-case letter, e.g. T, is used to denote an Ethereum transaction. This symbol may, if accordingly defined, be subscripted to refer to an individual component, e.g. [T](#page-9-0)n, denotes the nonce of said transaction. The form of the subscript is used to denote its type; e.g. uppercase subscripts refer to tuples with subscriptable components.

Scalars and fixed-size byte sequences (or, synonymously, arrays) are denoted with a normal lower-case letter, e.g. n is used in the document to denote a [transaction nonce.](#page-9-0) Those with a particularly special meaning may be Greek, e.g. δ, the number of items required on the stack for a given operation.

Arbitrary-length sequences are typically denoted as a bold lower-case letter, e.g. o is used to denote the byte sequence given as the output data of a message call. For particularly important values, a bold uppercase letter may be used.

Throughout, we assume scalars are non-negative integers and thus belong to the set N. The set of all byte sequences is B, formally defined in Appendix [B.](#page-19-0) If such a set of sequences is restricted to those of a particular length, it is denoted with a subscript, thus the set of all byte sequences of length 32 is named B<sup>32</sup> and the set of all non-negative integers smaller than 2<sup>256</sup> is named N256. This is formally defined in section [4.4.](#page-5-0)

Square brackets are used to index into and reference individual components or subsequences of sequences, e.g. µs [0] denotes the first item on the machine's stack. For subsequences, ellipses are used to specify the intended range, to include elements at both limits, e.g. µm[0..31] denotes the first 32 items of the machine's memory.

In the case of the global state σ, which is a sequence of accounts, themselves tuples, the square brackets are used to reference an individual account.

When considering variants of existing values, we follow the rule that within a given scope for definition, if we assume that the unmodified 'input' value be denoted by the placeholder then the modified and utilisable value is denoted as 0 , and intermediate values would be ∗ , ∗∗ &c. On very particular occasions, in order to maximise readability and only if unambiguous in meaning, we may use alpha-numeric subscripts to denote intermediate values, especially those of particular note.

When considering the use of existing functions, given a function f, the function [f](#page-6-0) <sup>∗</sup> denotes a similar, element-wise version of the function mapping instead between sequences. It is formally defined in section [4.4.](#page-5-0)

We define a number of useful functions throughout. One of the more common is `, which evaluates to the last item in the given sequence:

$$\ell(\mathbf{c}) \qquad \qquad \ell(\mathbf{x}) \equiv \mathbf{x}[||\mathbf{x}|| - 1]$$

## <span id="page-2-2"></span>4. Blocks, State and Transactions

Having introduced the basic concepts behind Ethereum, we will discuss the meaning of a transaction, a block and the state in more detail.

<span id="page-2-0"></span><sup>2</sup>Note that while the Paris, Shanghai, and every upcoming forks activated at a given block number (e.g. 15,537,394 for Paris), the trigger was not the block number, but rather reaching a specified timestamp (or total difficulty for Paris). The trigger for the Paris and subsequent hard fork are discussed in greater detail in section [10.](#page-15-2)

4.1. World State. The world state (state), is a mapping between addresses (160-bit identifiers) and account states (a data structure serialised as RLP, see Appendix [B\)](#page-19-0). Though not stored on the blockchain, it is assumed that the implementation will maintain this mapping in a modified Merkle Patricia tree (trie, see Appendix [D\)](#page-20-0). The trie requires a simple database backend that maintains a mapping of byte arrays to byte arrays; we name this underlying database the state database. This has a number of benefits; firstly the root node of this structure is cryptographically dependent on all internal data and as such its hash can be used as a secure identity for the entire system state. Secondly, being an immutable data structure, it allows any previous state (whose root hash is known) to be recalled by simply altering the root hash accordingly. Since we store all such root hashes in the blockchain, we are able to trivially revert to old states.

<span id="page-3-2"></span>The account state, σ[a], comprises the following four fields:

- nonce: A scalar value equal to the number of transactions sent from this address or, in the case of accounts with associated code, the number of contract-creations made by this account. For account of address a in state σ, this would be formally denoted σ[a]n.
- balance: A scalar value equal to the number of Wei owned by this address. Formally denoted σ[a]b.
- storageRoot: A 256-bit hash of the root node of a Merkle Patricia tree that encodes the storage contents of the account (a mapping between 256-bit integer values), encoded into the trie as a mapping from the Keccak 256-bit hash of the 256-bit integer keys to the RLP-encoded 256-bit integer values. The hash is formally denoted σ[a]s.
- codeHash: The hash of the EVM code of this account—this is the code that gets executed should this address receive a message call. All such code fragments are contained in the state database under their corresponding hashes for later retrieval. This hash is formally denoted σ[a]c, and thus the code may be denoted as b, given that KEC(b) = σ[a]c.

Since we typically wish to refer not to the trie's root hash but to the underlying set of key/value pairs stored within, we define a convenient equivalence:

$$(7) \qquad \qquad \mathsf{TRIE}\left(L\_1^\*\left(\sigma[a]\_\ast\right)\right) \equiv \sigma[a]\_\ast$$

The collapse function for the set of key/value pairs in the trie, L ∗ I , is defined as the element-wise transformation of the base function LI, given as:

$$(8) \qquad \qquad L\_{\mathrm{I}}\left((k, v)\right) \equiv \left(\mathsf{KEC}(k), \mathsf{RLP}(v)\right).$$

where:

$$(9) \qquad \qquad k \in \mathbb{B}\_{32} \quad \land \quad v \in \mathbb{N}$$

It shall be understood that σ[a]<sup>s</sup> is not a 'physical' member of the account and does not contribute to its later serialisation.

If the codeHash field is the Keccak-256 hash of the empty string, i.e. σ[a]<sup>c</sup> = KEC () , then the node represents a simple account, sometimes referred to as a "non-contract" account.

Thus we may define a world-state collapse function LS:

$$(10) \qquad \qquad L\_{\mathbb{S}}(\sigma) \equiv \{ p(a) : \sigma[a] \neq \mathcal{Q} \}$$

where

$$(11)\quad p(a) \equiv \left(\text{KEC}(a), \text{RLP}\left(\left(\sigma[a]\_{\text{n}}, \sigma[a]\_{\text{b}}, \sigma[a]\_{\text{s}}, \sigma[a]\_{\text{c}}\right)\right)\right)$$

This function, LS, is used alongside the trie function to provide a short identity (hash) of the world state. We assume:

$$(12)\qquad \forall a: \sigma[a] = \mathcal{Q} \lor \left(a \in \mathbb{B}\_{20} \land v(\sigma[a])\right)$$

where v is the account validity function:

(13) v(x) ≡ x<sup>n</sup> ∈ N256∧x<sup>b</sup> ∈ N256∧x<sup>s</sup> ∈ B32∧x<sup>c</sup> ∈ B<sup>32</sup>

An account is empty when it has no code, zero nonce and zero balance:

$$\begin{array}{rcl} \text{(14)}\\ \text{EMPTY}(\sigma, a) & \equiv & \sigma[a]\_{\text{c}} = \text{KEC}(\text{()}) \land \sigma[a]\_{\text{n}} = 0 \land \sigma[a]\_{\text{b}} = 0 \end{array}$$

Even callable precompiled contracts can have an empty account state. This is because their account states do not usually contain the code describing its behavior.

An account is dead when its account state is non-existent or empty:

$$\begin{array}{rcl} (15) & \mathsf{DEAD}(\sigma, a) & \equiv & \sigma[a] = \boxtimes \vee \mathsf{EMPTY}(\sigma, a) \end{array}$$

4.2. The Transaction. A transaction (formally, T) is a single cryptographically-signed instruction constructed by an actor externally to the scope of Ethereum. The sender of a transaction cannot be a contract. While it is assumed that the ultimate external actor will be human in nature, software tools will be used in its construction and dissemination[3](#page-3-0) . EIP-2718 by [Zoltu \[2020\]](#page-18-8) introduced the notion of different transaction types. As of the London version of the protocol, there are three transaction types: 0 (legacy), 1 (EIP-2930 by [Buterin and Swende \[2020b\]](#page-17-7)), and 2 (EIP-1559 by [Buterin et al. \[2019\]](#page-17-8)). Further, there are two subtypes of transactions: those which result in message calls and those which result in the creation of new accounts with associated code (known informally as 'contract creation'). All transaction types specify a number of common fields:

<span id="page-3-1"></span>type: EIP-2718 transaction type; formally Tx.

- nonce: A scalar value equal to the number of transactions sent by the sender; formally Tn.
- <span id="page-3-3"></span>gasLimit: A scalar value equal to the maximum amount of gas that should be used in executing this transaction. This is paid up-front, before any computation is done and may not be increased later; formally Tg.
- to: The 160-bit address of the message call's recipient or, for a contract creation transaction, ∅, used here to denote the only member of B<sup>0</sup> ; formally Tt.
- <span id="page-3-4"></span>value: A scalar value equal to the number of Wei to be transferred to the message call's recipient or, in the case of contract creation, as an endowment to the newly created account; formally Tv.

<span id="page-3-0"></span><sup>3</sup>Notably, such 'tools' could ultimately become so causally removed from their human-based initiation—or humans may become so causally-neutral—that there could be a point at which they rightly be considered autonomous agents. e.g. contracts may offer bounties to humans for being sent transactions to initiate their execution.

<span id="page-4-7"></span>r, s: Values corresponding to the signature of the transaction and used to determine the sender of the transaction; formally T<sup>r</sup> and Ts. This is expanded in Appendix [F.](#page-25-0)

EIP-2930 (type 1) and EIP-1559 (type 2) transactions also have:

- <span id="page-4-6"></span>accessList: List of access entries to warm up; formally TA. Each access list entry E is a tuple of an account address and a list of storage keys: E ≡ (Ea, Es).
- chainId: Chain ID; formally Tc. Must be equal to the network chain ID [β](#page-2-1).

yParity: Signature Y parity; formally Ty.

Legacy transactions do not have an accessList (T<sup>A</sup> = ()), while chainId and yParity for legacy transactions are combined into a single value:

<span id="page-4-8"></span>w: A scalar value encoding Y parity and possibly chain ID; formally Tw. T<sup>w</sup> = 27 + T<sup>y</sup> or T<sup>w</sup> = 2β + 35+T<sup>y</sup> (see EIP-155 by [Buterin \[2016\]](#page-17-5)).

There are differences in how one's acceptable gas price is specified in type 2 transactions versus type 0 and type 1 transactions. Type 2 transactions take better advantage of the gas market improvements introduced in EIP-1559 by explicitly limiting the priority fee[4](#page-4-1) that is paid. Type 2 transactions have the following two fields related to gas:

- maxFeePerGas: A scalar value equal to the maximum number of Wei to be paid per unit of gas for all computation costs incurred as a result of the execution of this transaction; formally Tm.
- maxPriorityFeePerGas: A scalar value equal to the maximum number of Wei to be paid to the block's fee recipient as an incentive to include the transaction; formally Tf.

In contrast, type 0 and type 1 transactions specify gas price as a single value:

gasPrice: A scalar value equal to the number of Wei to be paid per unit of gas for all computation costs incurred as a result of the execution of this transaction; formally Tp. [5](#page-4-2)

Additionally, a contract creation transaction (regardless of transaction type) contains:

init: An unlimited size byte array specifying the EVM-code for the account initialisation procedure, formally Ti.

init is an EVM-code fragment; it returns the body, a second fragment of code that executes each time the account receives a message call (either through a transaction or due to the internal execution of code). init is executed only once at account creation and gets discarded immediately thereafter.

In contrast, a message call transaction contains:

data: An unlimited size byte array specifying the input data of the message call, formally Td.

Appendix [F](#page-25-0) specifies the function, S, which maps transactions to the sender, and happens through the ECDSA of the SECP-256k1 curve, using the hash of the transaction (excepting the latter three signature fields) as the datum

to sign. For the present we simply assert that the sender of a given transaction T can be represented with S(T).

(16)

<span id="page-4-5"></span>
$$L\_{\mathbf{T}}(T) \equiv \begin{cases} \langle T\_{\mathbf{n}}, T\_{\mathbf{p}}, T\_{\mathbf{g}}, T\_{\mathbf{t}}, T\_{\mathbf{v}}, \mathbf{p}, T\_{\mathbf{w}}, T\_{\mathbf{r}}, T\_{\mathbf{s}} \rangle & \text{if } T\_{\mathbf{x}} = 0 \\ \langle T\_{\mathbf{c}}, T\_{\mathbf{n}}, T\_{\mathbf{p}}, T\_{\mathbf{g}}, T\_{\mathbf{t}}, T\_{\mathbf{v}}, \mathbf{p}, T\_{\mathbf{A}}, T\_{\mathbf{y}}, T\_{\mathbf{r}}, T\_{\mathbf{s}} \rangle & \text{if } T\_{\mathbf{x}} = 1 \\ \langle T\_{\mathbf{c}}, T\_{\mathbf{n}}, T\_{\mathbf{f}}, T\_{\mathbf{m}}, T\_{\mathbf{g}}, T\_{\mathbf{t}}, T\_{\mathbf{v}}, \mathbf{p}, T\_{\mathbf{A}}, T\_{\mathbf{y}}, T\_{\mathbf{r}}, T\_{\mathbf{s}} \rangle & \text{if } T\_{\mathbf{x}} = 2 \end{cases}$$

where

$$\begin{array}{cc} \text{(17)} & \mathbf{p} \equiv \begin{cases} T\_{\mathbf{i}} & \text{if } T\_{\mathbf{i}} = \mathcal{Q} \\ T\_{\mathbf{d}} & \text{otherwise} \end{cases} \end{array}$$

Here, we assume all components are interpreted by the RLP as integer values, with the exception of the access list T<sup>A</sup> and the arbitrary length byte arrays T<sup>i</sup> and Td. (18)

| Tx ∈ {0, 1, 2} | ∧ | Tc = β    | ∧ | Tn ∈ N256 | ∧ |
|----------------|---|-----------|---|-----------|---|
| Tp ∈ N256      | ∧ | Tg ∈ N256 | ∧ | Tv ∈ N256 | ∧ |
| Tw ∈ N256      | ∧ | Tr ∈ N256 | ∧ | Ts ∈ N256 | ∧ |
| Ty ∈ N1        | ∧ | Td ∈ B    | ∧ | Ti ∈ B    | ∧ |
| Tm ∈ N256      | ∧ | Tf ∈ N256 |   |           |   |

where

$$(19) \qquad \mathbb{N}\_{\mathbb{n}} = \{ P : P \in \mathbb{N} \land P < 2^n \}$$

The address hash T<sup>t</sup> is slightly different: it is either a 20-byte address hash or, in the case of being a contractcreation transaction (and thus formally equal to ∅), it is the RLP empty byte sequence and thus the member of B0:

$$(20) \qquad \qquad T\_{\mathbf{t}} \in \begin{cases} \mathbb{B}\_{20} & \text{if} \quad T\_{\mathbf{t}} \neq \mathcal{D} \\ \mathbb{B}\_{0} & \text{otherwise} \end{cases}$$

<span id="page-4-0"></span>4.3. The Withdrawal. A withdrawal (formally, W ) is a tuple of data describing a consensus layer validator's withdrawal of some amount of its staked Ether. A withdrawal is created and validated in the consensus layer of the blockchain and then pushed to the execution layer. A withdrawal is composed of the following fields:

- globalIndex: zero based incrementing withdrawal index that acts as a unique identifier for this withdrawal; formally Wg.
- validatorIndex: index of consensus layer's validator this withdrawal corresponds to; formally Wv.
- recipient: the 20-byte address that will receives Ether from this withdrawal; formally Wr.
- amount: a nonzero amount of Ether denominated in Gwei (10<sup>9</sup> Wei); formally Wa.

<span id="page-4-4"></span>Withdrawal serialisation is defined as:

$$(21) \qquad \qquad L\_{\rm W}(W) \equiv (W\_{\rm g}, W\_{\rm v}, W\_{\rm r}, T\_{\rm a})$$

Here, we assume all components are interpreted by the RLP as integer values except for W<sup>r</sup> which is a 20-byte address:

$$\begin{array}{ccccc}(22) & W\_{\text{g}} \in \mathbb{N}\_{64} & \land & W\_{\text{v}} \in \mathbb{N}\_{64} & \land\\ & W\_{\text{v}} \in \mathbb{B}\_{20} & \land & W\_{\text{a}} \in \mathbb{N}\_{64}\end{array}$$

<span id="page-4-3"></span><span id="page-4-2"></span>

<span id="page-4-1"></span><sup>4</sup>The priority fee is discussed in greater detail in sections [5](#page-7-0) and [6.](#page-8-0)

<sup>5</sup>Type 0 and type 1 transactions will get the same gas price behavior as a type 2 transaction with T<sup>m</sup> and T<sup>f</sup> set to the value of Tp. <sup>6</sup>ommer is a gender-neutral term to mean "sibling of parent"; see [https://nonbinary.miraheze.org/wiki/Gender\\_neutral\\_language\\_in\\_](https://nonbinary.miraheze.org/wiki/Gender_neutral_language_in_English#Aunt/Uncle)

[English#Aunt/Uncle](https://nonbinary.miraheze.org/wiki/Gender_neutral_language_in_English#Aunt/Uncle)

<span id="page-5-0"></span>4.4. The Block. The block in Ethereum is the collection of relevant pieces of information (known as the block header ), H, together with information corresponding to the comprised transactions, T, a now deprecated property U that prior to the Paris hard fork contained headers of blocks whose parents were equal to the present block's parent's parent (such blocks were known as ommers[6](#page-4-3) ), and, since the Shanghai hard fork, W, a collection of validator's withdrawal pushed by the consensus layer. The block header contains several pieces of information:

- <span id="page-5-6"></span>parentHash: The Keccak 256-bit hash of the parent block's header, in its entirety; formally Hp.
- ommersHash: A 256-bit hash field that is now deprecated due to the replacement of proof of work consensus. It is now to a constant, KEC(RLP(())); formally Ho.
- beneficiary: The 160-bit address to which priority fees from this block are transferred; formally Hc.
- stateRoot: The Keccak 256-bit hash of the root node of the state trie, after all transactions and withdrawals are executed and finalisations applied; formally Hr.
- transactionsRoot: The Keccak 256-bit hash of the root node of the trie structure populated with each transaction in the transactions list portion of the block; formally Ht.
- receiptsRoot: The Keccak 256-bit hash of the root node of the trie structure populated with the receipts of each transaction in the transactions list portion of the block; formally He.
- logsBloom: The Bloom filter composed from indexable information (logger address and log topics) contained in each log entry from the receipt of each transaction in the transactions list; formally Hb.
- difficulty: A scalar field that is now deprecated due to the replacement of proof of work consensus. It is set to 0; formally Hd.
- number: A scalar value equal to the number of ancestor blocks. The genesis block has a number of zero; formally [H](#page-6-1)i.
- gasLimit: A scalar value equal to the current limit of gas expenditure per block; formally Hl.
- <span id="page-5-11"></span>gasUsed: A scalar value equal to the total gas used in transactions in this block; formally Hg.
- timestamp: A scalar value equal to the reasonable output of Unix's time() at this block's inception; formally [H](#page-7-1)s.
- <span id="page-5-7"></span>extraData: An arbitrary byte array containing data relevant to this block. This must be 32 bytes or fewer; formally Hx.
- prevRandao: the latest RANDAO mix[7](#page-5-1) of the post beacon state of the previous block; formally Ha.
- <span id="page-5-8"></span>nonce: A 64-bit value that is now deprecated due to the replacement of proof of work consensus. It is set to 0x0000000000000000; formally [H](#page-0-0)n.
- <span id="page-5-9"></span>baseFeePerGas: A scalar value equal to the amount of wei that is burned for each unit of gas consumed; formally [H](#page-6-2)f.

<span id="page-5-5"></span>The other three components in the block are a series of transactions, BT, an empty array which was previously reserved for ommer block headers, BU, and a series of withdrawals, BW. Formally, we can refer to a block B:

$$(23) \qquad \qquad B \equiv (B\_{\rm H}, B\_{\rm T}, B\_{\rm U}, B\_{\rm W})$$

<span id="page-5-4"></span>4.4.1. Transaction Receipt. In order to encode information about a transaction concerning which it may be useful to form a zero-knowledge proof, or index and search, we encode a receipt of each transaction containing certain information from its execution. Each receipt, denoted BR[i] for the ith transaction, is placed in an index-keyed [trie](#page-20-1) and the root recorded in the header as [H](#page-6-3)e.

<span id="page-5-12"></span>The transaction receipt, R, is a tuple of five items comprising: the type of the transaction, Rx, the status code of the transaction, Rz, the cumulative gas used in the block containing the transaction receipt as of immediately after the transaction has happened, Ru, the set of logs created through execution of the transaction, [R](#page-19-1)<sup>l</sup> and the Bloom filter composed from information in those logs, [R](#page-19-2)b:

$$(24) \qquad \qquad R \equiv (R\_{\mathbf{x}}, R\_{\mathbf{z}}, R\_{\mathbf{u}}, R\_{\mathbf{b}}, R\_{\mathbf{l}})$$

<span id="page-5-3"></span>R<sup>x</sup> is equal to the [type](#page-3-1) of the corresponding transaction. The function L<sup>R</sup> prepares a transaction receipt for being transformed into an RLP-serialised byte array:

$$(25) \qquad \qquad L\_{\rm R}(R) \equiv (R\_{\rm a}, R\_{\rm u}, R\_{\rm b}, R\_{\rm l})$$

We assert that the status code R<sup>z</sup> is a non-negative integer:

$$(26) \qquad \qquad \qquad \qquad R\_{\mathfrak{a}} \in \mathbb{N}$$

We assert that Ru, the cumulative gas used, is a nonnegative integer and that the logs Bloom, Rb, is a hash of size 2048 bits (256 bytes):

$$(27) \newline \qquad \qquad R\_{\mathsf{u}} \in \mathbb{N} \quad \land \quad R\_{\mathsf{b}} \in \mathbb{B}\_{256}$$

The sequence R<sup>l</sup> is a series of log entries, (O0, O1, ...). A log entry, O, is a tuple of the logger's address, Oa, a possibly empty series of 32-byte log topics, O<sup>t</sup> and some number of bytes of data, Od:

$$(28) \qquad \qquad O \equiv (O\_{\mathbf{a}}, (O\_{\mathbf{t}0}, O\_{\mathbf{t}1}, ...), O\_{\mathbf{d}})$$

$$(29) \quad O\_{\mathbf{a}} \in \mathbb{B}\_{20} \quad \land \quad \forall x \in O\_{\mathbf{t}} : x \in \mathbb{B}\_{32} \quad \land \quad O\_{\mathbf{d}} \in \mathbb{B}\_{2}$$

We define the Bloom filter function, M, to reduce a log entry into a single 256-byte hash:

$$(30) \qquad M(O) \equiv \bigvee\_{x \in \{O\_\mathbf{a}\} \cup O\_\mathbf{t}} \left( M\_{3:2048}(x) \right),$$

where M3:2048 is a specialised Bloom filter that sets three bits out of 2048, given an arbitrary byte sequence. It does this through taking the low-order 11 bits of each of the first three pairs of bytes in a Keccak-256 hash of the byte

<span id="page-5-10"></span>withdrawalsRoot: The Keccak 256-bit hash of the root node of the trie structure populated with each withdrawal operations pushed by the consensus layer for this block; formally [H](#page-0-0)w.

<span id="page-5-1"></span><sup>7</sup>RANDAO is a pseudorandom value generated by validators on the Ethereum consensus layer. Refer to the consensus layer specs (<https://github.com/ethereum/consensus-specs>) for more detail on RANDAO.

<span id="page-5-2"></span><sup>8</sup>2048 = 211(11 bits), and the low-order 11 bits is the modulo 2048 of the operand, which is in this case is "each of the first three pairs of bytes in a Keccak-256 hash of the byte sequence."

sequence.[8](#page-5-2) Formally:

$$\begin{array}{rclcrcl}(31)M\_{3\cdot 2048}(\mathbf{x}:\mathbf{x}\in\mathbb{B}) & \equiv & \mathbf{y}:\mathbf{y}\in\mathbb{B}\_{256} & \text{where:}\\(32) & & \mathbf{y} & = & (0,0,\ldots,0) & \text{except:}\\(33) & & \forall i\in\{0,2,4\} & : & \mathcal{B}\_{2047-m(\mathbf{x},i)}(\mathbf{y})=1\\(34) & & m(\mathbf{x},i) & \equiv & \mathsf{KEC}(\mathbf{x})[i,i+1] \bmod 2048\end{array}$$

where B is the bit reference function such that Bj(x) equals the bit of index j (indexed from 0) in the byte array x. Notably, it treats x as big-endian (more significant bits will have smaller indices).

4.4.2. Holistic Validity. We can assert a block's validity if and only if it satisfies several conditions: the block's ommers field B<sup>U</sup> must be an empty array and the block's header must be consistent with the given transactions B<sup>T</sup> and withdrawals BW. For the header to be consistent with the transactions B<sup>T</sup> and withdrawals BW, state-Root (Hr) must match the resultant state after executing all transactions, then all withdrawals, in order on the base state σ (as specified in section [12\)](#page-15-0), and transactions-Root (Ht), receiptsRoot (He), logsBloom (Hb) and withdrawalsRoot (Hw) must be correctly derived from the transactions themselves, the transaction receipts resulting from execution, the resulting logs, and the withdrawals, respectively.

<span id="page-6-4"></span><span id="page-6-3"></span>
$$\begin{array}{rcll} (35) & \quad B\_{\mathbf{U}} & \equiv & () \\ & H\_{\mathbf{r}} & \equiv & \mathbf{TRIE}(L\_{S}(\Pi(\sigma, B))) & \wedge \\ & H\_{\mathbf{t}} & \equiv & \mathbf{TRIE}(\{\forall i < \|B\_{\mathbf{T}}\|\}, i \in \mathbb{N}: \\ & & p\_{\mathbf{T}}(i, B\_{\mathbf{T}}[i])) & \wedge \\ & H\_{\mathbf{e}} & \equiv & \mathbf{TRIE}(\{\forall i < \|B\_{\mathbf{R}}\|\}, i \in \mathbb{N}: \\ & & p\_{\mathbf{R}}(i, B\_{\mathbf{R}}[i])) & \wedge \\ & H\_{\mathbf{w}} & \equiv & \mathbf{TRIE}(\{\forall i < \|B\_{\mathbf{W}}\|\}, i \in \mathbb{N}: \\ & & p\_{\mathbf{W}}(i, B\_{\mathbf{W}}[i])) & \wedge \\ & & H\_{\mathbf{b}} & \equiv & \bigvee\_{\mathbf{r} \in B\_{\mathbf{R}}} \left(\mathbf{r}\_{\mathbf{b}}\right) \end{array}$$

<span id="page-6-5"></span>where pW(k, v) is a pairwise RLP transformation for withdrawals:

$$(36) \qquad p\_W(k, W) \equiv (\mathsf{RLP}(k), \mathsf{RLP}(L\_W(W)))$$

similarly, pT(k, v) and pR(k, v) are pairwise RLP transformations, but with a special treatment for EIP-2718 transactions: (37)

$$p\_{\mathcal{T}}(k,T) \equiv \begin{pmatrix} \mathsf{RLP}(k), \begin{cases} \mathsf{RLP}(L\_{\mathcal{T}}(T)) & \text{if } \quad T\_{\mathcal{X}} = 0 \\ \left(T\_{\mathcal{X}}\right) \cdot \mathsf{RLP}(L\_{\mathcal{T}}(T)) & \text{otherwise} \end{cases} \end{pmatrix}$$

and

$$\begin{cases} (38) \\ p\_{\mathcal{R}}(k, R) \equiv \begin{pmatrix} \text{RLP}(k), \begin{cases} \text{RLP}(L\_{\mathcal{R}}(R)) & \text{if } \quad R\_{\mathcal{X}} = 0 \\ (R\_{\mathcal{X}}) \cdot \text{RLP}(L\_{\mathcal{R}}(R)) & \text{otherwise} \end{cases} \end{cases} \end{cases}$$

(· is the concatenation of byte arrays).

Furthermore:

$$(39)\_{\text{cr}} \qquad \qquad \mathsf{TRIE}(L\_{\text{S}}(\sigma)) = P(B\_H)\_{H\_{\text{cr}}}$$

Thus TRIE(LS(σ)) is the root node hash of the Merkle Patricia tree structure containing the key-value pairs of the state σ with values encoded using RLP, and P(BH) is the parent block of B, defined directly.

The values stemming from the computation of transactions, specifically the [transaction receipts,](#page-5-4) BR, and that defined through the transaction's [state-accumulation func](#page-16-0)[tion, Π,](#page-16-0) are formalised later in section [12.3.](#page-16-1)

4.4.3. Serialisation. The function L<sup>B</sup> and L<sup>H</sup> are the preparation functions for a block and block header respectively. We assert the types and order of the structure for when the RLP transformation is required:

$$\begin{array}{rclcrcl}(40) \mathbf{L}\_{\mathrm{H}}(H) & \equiv & \left( \begin{array}{c} H\_{\mathrm{P}}, H\_{\mathrm{O}}, H\_{\mathrm{C}}, H\_{\mathrm{T}}, H\_{\mathrm{t}}, H\_{\mathrm{a}}, H\_{\mathrm{b}}, H\_{\mathrm{d}}, \\\ H\_{\mathrm{i}}, H\_{\mathrm{i}}, H\_{\mathrm{g}}, H\_{\mathrm{s}}, H\_{\mathrm{x}}, H\_{\mathrm{a}}, H\_{\mathrm{n}}, H\_{\mathrm{f}}, H\_{\mathrm{w}} \end{array} \right) \\\\ (41) \boldsymbol{L}\_{\mathrm{B}}(B) & \equiv & \left( \begin{array}{c} \boldsymbol{L}\_{\mathrm{H}}(B\_{\mathrm{H}}), \widetilde{\boldsymbol{L}}\_{\mathrm{T}}^{\star}(B\_{\mathrm{T}}), \boldsymbol{L}\_{\mathrm{H}}^{\star}(B\_{\mathrm{U}}), \boldsymbol{L}\_{\mathrm{W}}^{\star}(B\_{\mathrm{W}}) \end{array} \right) \end{array}$$

where <sup>L</sup>e<sup>T</sup> takes a special care of EIP-2718 transactions:

$$\begin{aligned} \text{(42)} \qquad \tilde{L}\_{\text{T}}(T) = \begin{cases} L\_{\text{T}}(T) & \text{if} \quad T\_{\text{x}} = 0\\ \text{( $T\_{\text{x}}$ )} \cdot \text{RLP}(L\_{\text{T}}(T)) & \text{otherwise} \end{cases} \end{aligned}$$

<span id="page-6-0"></span>with <sup>L</sup>e<sup>∗</sup> <sup>T</sup>, L ∗ <sup>H</sup>, and L ∗ W, being element-wise sequence transformations, thus:

(43) f ∗ (x0, x1, ...) ≡ f(x0), f(x1), ... for any function f

The component types are defined thus:

$$\begin{array}{ccccc} \text{(44)} & H\_{\text{P}} \in \mathbb{B}\_{32} & \wedge & H\_{\text{o}} \in \mathbb{B}\_{32} & \wedge & H\_{\text{c}} \in \mathbb{B}\_{20} & \wedge \\ & H\_{\text{r}} \in \mathbb{B}\_{32} & \wedge & H\_{\text{t}} \in \mathbb{B}\_{32} & \wedge & H\_{\text{e}} \in \mathbb{B}\_{32} & \wedge \\ & H\_{\text{b}} \in \mathbb{B}\_{256} & \wedge & H\_{\text{d}} \in \mathbb{N} & \wedge & H\_{\text{l}} \in \mathbb{N} & \wedge \\ & H\_{\text{l}} \in \mathbb{N} & \wedge & H\_{\text{g}} \in \mathbb{N} & \wedge & H\_{\text{s}} \in \mathbb{N}\_{256} & \wedge \\ & H\_{\text{x}} \in \mathbb{B} & \wedge & H\_{\text{a}} \in \mathbb{B}\_{32} & \wedge & H\_{\text{n}} \in \mathbb{B}\_{8} & \wedge \\ & H\_{\text{f}} \in \mathbb{N} & \wedge & H\_{\text{w}} \in \mathbb{B}\_{32} & & \\ \end{array}$$

where

$$\text{(45)}\qquad\mathbb{B}\_{\text{n}} = \{B : B \in \mathbb{B} \land \|B\| = n\}$$

We now have a rigorous specification for the construction of a formal block structure. The RLP function RLP (see Appendix [B\)](#page-19-0) provides the canonical method for transforming this structure into a sequence of bytes ready for transmission over the wire or storage locally.

4.4.4. Block Header Validity. We define P(BH) to be the parent block of B, formally:

$$(46) \qquad P(H) \equiv B' : \mathsf{KEC}(\mathsf{RLP}(B\_{\mathsf{H}}')) = H\_{\mathsf{P}}$$

<span id="page-6-1"></span>The block number is the parent's block number incremented by one:

$$(47) \tag{47} \tag{48}$$

$$H\_1 \equiv P(H)\_{H\_1} + 1$$

<span id="page-6-2"></span>The London release introduced the block attribute base fee per gas [H](#page-5-9)<sup>f</sup> (see EIP-1559 by [Buterin et al. \[2019\]](#page-17-8)). The base fee is the amount of wei burned per unit of gas consumed while executing transactions within the block. The value of the base fee is a function of the difference between the gas used by the parent block and the parent block's gas target.

The expected base fee per gas is defined as F(H):

$$\text{(48)}\qquad F(H) \equiv \begin{cases} 1000000000 & \text{if} \quad H\_{\text{i}} = F\_{\text{London}} \\ P(H)\_{\text{H}\_{\text{f}}} & \text{if} \quad P(H)\_{\text{H}\_{\text{g}}} = \tau \\ P(H)\_{\text{H}\_{\text{f}}} - \nu & \text{if} \quad P(H)\_{\text{H}\_{\text{g}}} < \tau \\ P(H)\_{\text{H}\_{\text{f}}} + \nu & \text{if} \quad P(H)\_{\text{H}\_{\text{g}}} > \tau \end{cases} \tag{8}$$

where:

$$(49) \qquad \tau \equiv \lfloor \frac{P(H)\_{\mathcal{H}\_1}}{\rho} \rfloor$$

$$(50) \qquad \rho \equiv 2$$

$$\text{(51)}\quad \nu^\* \equiv \begin{cases} \lfloor \frac{P(H)\_{\text{Hf}} \times (\tau - P(H)\_{\text{H}\_{\text{g}}})}{\tau} \rfloor & \text{if} \quad P(H)\_{\text{H}\_{\text{g}}} < \tau\\ \lfloor \frac{P(H)\_{\text{Hf}} \times (\tilde{P}(H)\_{\text{H}\_{\text{g}}} - \tau)}{\tau} \rfloor & \text{if} \quad P(H)\_{\text{H}\_{\text{g}}} > \tau \end{cases}$$

$$\begin{cases} \text{(52)} & \nu \equiv \begin{cases} \lfloor \frac{\nu^\*}{\xi} \rfloor & \text{if } & P(H)\_{\text{H}\_\text{g}} < \tau \\ \max\{ \lfloor \frac{\nu^\*}{\xi} \rfloor, 1 \} & \text{if } & P(H)\_{\text{H}\_\text{g}} > \tau \end{cases} \end{cases}$$

ξ ≡ 8(53)

The gas target, τ , is defined as the gas limit H<sup>l</sup> divided by the elasticity multiplier, ρ, a global constant set to 2. So while blocks can consume as much gas as the gas limit, the base fee is adjusted so that on average, blocks consume as much gas as the gas target. The base fee is increased in the current block when the parent block's gas usage exceeds the gas target, and, conversely, the base fee is decreased in the current block when the parent block's gas usage is less than the gas target.

The magnitude of the increase or decrease in the base fee, defined as ν, is proportional to the difference between the amount of gas the parent block consumed and the parent block's gas target. The effect on the base fee is dampened by a global constant called the base fee max change denominator, formally ξ, set to 8. A value of 8 entails that the base fee can increase or decrease by at most 12.5% from one block to the next.

<span id="page-7-2"></span>The canonical gas limit H<sup>l</sup> of a block of header H must fulfil the relation:

$$\begin{aligned} \text{(54)} \qquad &H\_1 < P(H)\_{\text{H}\_{\text{I}}} + \left\lfloor \frac{P(H)\_{\text{H}\_{\text{I}}}}{1024} \right\rfloor \quad \land \\ &H\_1 > P(H)\_{\text{H}\_{\text{I}}} - \left\lfloor \frac{P(H)\_{\text{H}\_{\text{I}}}}{1024} \right\rfloor \quad \land \\ &H\_1 \gtrless 5000 \end{aligned}$$

where:

$$(55) \qquad P(H)\_{\mathrm{H}\_{\mathrm{I}}\prime} \equiv \begin{cases} P(H)\_{\mathrm{H}\_{\mathrm{I}}} \times \rho & \text{if} \quad H\_{\mathrm{I}} = F\_{\mathrm{London}} \\ P(H)\_{\mathrm{H}\_{\mathrm{I}}} & \text{if} \quad H\_{\mathrm{I}} > F\_{\mathrm{London}} \end{cases}$$

To avoid a discontinuity in gas usage, the value of the parent block gas limit for the purpose of validating the current block's gas limit is modified at the London fork block by multiplying it by the elasticity multiplier, ρ. We call this modified value P(H)Hl <sup>0</sup> . This ensures that the gas target for post-London blocks can be set roughly in line with the gas limit of pre-London blocks.

<span id="page-7-1"></span>H<sup>s</sup> is the timestamp (in Unix's time()) of block H and must fulfil the relation:

$$\text{(56)}\tag{56}$$

$$H\_k > P(H)\_{H\_{st}}$$

The Paris hard fork changed Ethereum's consensus from proof of work to proof of stake, and thus deprecated many block header properties related to proof of work. These deprecated properties include nonce (Hn), ommersHash (Ho), difficulty (Hd), and mixHash (Hm).

mixHash has been replaced with a new field prevRandao (Ha). The other header fields related to proof of work have been replaced with constants:

$$\begin{array}{ccccc}(57) & H\_{\text{o}} & \equiv & \mathsf{KEC(RLP())}\text{)}\\(58) & H\_{\text{d}} & \equiv & 0\\(59) & H\_{\text{n}} & \equiv & \mathsf{0x000000000000000000000}\end{array}$$

The value of prevRandao must be determined using information from the Beacon Chain. While the details of generating the RANDAO value on the Beacon Chain is beyond the scope of this paper, we refer to the expected RANDAO value for the previous block as PREVRANDAO().

Thus we are able to define the block header validity function V (H):

$$\begin{array}{ccccc}\text{(60)} & V(H) & \equiv & H\_{\text{g}} \le H\_{\text{l}} & \wedge \\ \end{array}$$

$$\begin{aligned} H\_{\text{l}} &< P(H)\_{\text{H}\_{\text{l}}\prime} + \left\lfloor \frac{P(H)\_{\text{H}\_{\text{l}}\prime}}{1024} \right\rfloor \quad \wedge \\ H\_{\text{l}} &> P(H)\_{\text{H}\_{\text{l}}\prime} - \left\lfloor \frac{P(H)\_{\text{H}\_{\text{l}}\prime}}{1024} \right\rfloor \quad \wedge \\ H\_{\text{l}} &\ge 5000 \quad \wedge \\ H\_{\text{s}} &> P(H)\_{\text{H}\_{\text{s}}} \quad \wedge \\ H\_{\text{l}} &= P(H)\_{\text{H}\_{\text{l}}} + 1 \quad \wedge \\ ||H\_{\text{x}}|| &\le 32 \quad \wedge \\ H\_{\text{f}} &= F(H) \wedge \\ H\_{\text{o}} &= \mathsf{KEC}(\mathsf{RLP}(\{\})) \quad \wedge \\ H\_{\text{d}} &= 0 \quad \wedge \\ H\_{\text{n}} &= 0 \quad \wedge \\ H\_{\text{n}} &= \mathsf{PREV}(\mathsf{RLD}(\text{a})) \end{aligned}$$

Note additionally that extraData must be at most 32 bytes.

### 5. Gas and Payment

<span id="page-7-0"></span>In order to avoid issues of network abuse and to sidestep the inevitable questions stemming from Turing completeness, all programmable computation in Ethereum is subject to fees. The fee schedule is specified in units of gas (see Appendix [G](#page-27-0) for the fees associated with various computation). Thus any given fragment of programmable computation (this includes creating contracts, making message calls, utilising and accessing account storage and executing operations on the virtual machine) has a universally agreed cost in terms of gas.

Every transaction has a specific amount of gas associated with it: gasLimit. This is the amount of gas which is implicitly purchased from the sender's account balance. The purchase happens at the effective gas price defined in section [6.](#page-8-0) The transaction is considered invalid if the account balance cannot support such a purchase. It is named gasLimit since any unused gas at the end of the transaction is refunded (at the same rate of purchase) to the sender's account. Gas does not exist outside of the execution of a transaction. Thus for accounts with trusted code associated, a relatively high gas limit may be set and left alone.

Since the introduction of EIP-1559 by [Buterin et al.](#page-17-8) [\[2019\]](#page-17-8) in the London hard fork, every transaction included in a block must pay a base fee, which is specified as wei per unit of gas consumed and is constant for each transaction within a block. The ether that is paid to meet the base fee is burned (taken out of circulation). The base fee adjusts dynamically as a function of the previous

block's gas consumption relative to its gas target (a value that is currently half the block's gas limit, which can be adjusted by validators). If the previous block's total gas consumption exceeds the gas target, this indicates excess demand for block space at the current base fee, and the base fee is increased. Conversely, if the gas consumed in the previous block is lower than the gas target, demand for block space is lower than the gas target at the current base fee, and thus the base fee is decreased. This process of adjusting the base fee should bring the average block's gas consumption in line with the gas target. Refer to section [4.4](#page-5-0) for greater detail on how the base fee is set.

To incentivize validators to include transactions, there is an additional fee known as a priority fee, which is also specified as wei per unit of gas consumed. The total fee paid by the transactor therefore is the sum of the base fee per gas and the priority fee per gas multiplied by the total gas consumed. Ether used to satisfy the priority fee is delivered to the beneficiary address, the address of an account typically under the control of the validator.

Transactors using type 2 transactions can specify the maximum priority fee they are willing to pay (maxPriorityFeePerGas) as well as the max total fee they are willing to pay (maxFeePerGas), inclusive of both the priority fee and the base fee. maxFeePerGas must be at least as high as the base fee for the transaction to be included in a block. Type 0 and type 1 transactions have only one field for specifiying a gas price–gasPrice– which also must be at least as high as the base fee for inclusion in a block. The amount by which gasPrice is higher than the base fee constitutes the priority fee in the case of a type 0 or type 1 transaction.

Transactors are free to select any priority fee that they wish, however validators are free to ignore transactions as they choose. A higher priority fee on a transaction will therefore cost the sender more in terms of Ether and deliver a greater value to the validator and thus will more likely be selected for inclusion. Since there will be a (weighted) distribution of minimum acceptable priority fees, transactors will necessarily have a trade-off to make between lowering the priority fee and maximising the chance that their transaction will be included in a block in a timely manner.

### 6. Transaction Execution

<span id="page-8-0"></span>The execution of a transaction is the most complex part of the Ethereum protocol: it defines the state transition function [Υ.](#page-1-0) It is assumed that any transactions executed first pass the initial tests of intrinsic validity. These include:

- (1) The transaction is well-formed RLP, with no additional trailing bytes;
- (2) the transaction signature is valid;
- (3) the [transaction nonce](#page-9-0) is valid (equivalent to the [sender account's current nonce\)](#page-3-2);
- (4) the sender account has no contract code deployed (see EIP-3607 by [Feist et al. \[2021\]](#page-17-9));
- (5) the gas limit is no smaller than the intrinsic gas, g0, used by the transaction;
- (6) the sender account balance contains at least the cost, v0, required in up-front payment;
- (7) the maxFeePerGas, Tm, in the case of type 2 transactions, or gasPrice, Tp, in the case of type

0 and type 1 transactions, is greater than or equal to the block's base fee, Hf; and

(8) for type 2 transactions, maxPriorityFeePer-Gas, T<sup>f</sup> , must be no larger than maxFeePerGas, Tm.

Formally, we consider the function [Υ,](#page-1-0) with T being a transaction and σ the state:

$$\text{(61)}\qquad\qquad\qquad\qquad\sigma'=\Upsilon(\sigma,T)\tag{19}$$

Thus σ 0 is the post-transactional state. We also define [Υ](#page-10-0) g to evaluate to the amount of gas used in the execution of a transaction, [Υ](#page-10-0)<sup>l</sup> to evaluate to the transaction's accrued log items and [Υ](#page-10-0)<sup>z</sup> to evaluate to the status code resulting from the transaction. These will be formally defined later.

<span id="page-8-3"></span>6.1. Substate. Throughout transaction execution, we accrue certain information that is acted upon immediately following the transaction. We call this the accrued transaction substate, or accrued substate for short, and represent it as A, which is a tuple:

$$(62) \qquad \qquad A \equiv (A\_{\mathbf{a}}, A\_{\mathbf{l}}, A\_{\mathbf{t}}, A\_{\mathbf{r}}, A\_{\mathbf{a}}, A\_{\mathbf{K}})$$

<span id="page-8-2"></span>The tuple contents include As, the self-destruct set: a set of accounts that will be discarded following the transaction's completion. A<sup>l</sup> is the log series: this is a series of archived and indexable 'checkpoints' in VM code execution that allow for contract-calls to be easily tracked by onlookers external to the Ethereum world (such as decentralised application front-ends). A<sup>t</sup> is the set of touched accounts, of which the empty ones are deleted at the end of a transaction. A<sup>r</sup> is the refund balance, increased through using the [SSTORE](#page-34-1) instruction in order to reset contract storage to zero from some non-zero value. Though not immediately refunded, it is allowed to partially offset the total execution costs. Finally, EIP-2929 by [Buterin and Swende \[2020a\]](#page-17-10) introduced Aa, the set of accessed account addresses, and AK, the set of accessed storage keys (more accurately, each element of A<sup>K</sup> is a tuple of a 20-byte account address and a 32-byte storage slot).

<span id="page-8-4"></span><span id="page-8-1"></span>We define the empty accrued substate A 0 to have no self-destructs, no logs, no touched accounts, zero refund balance, all precompiled contracts in the accessed addresses, and no accessed storage:

(63) A <sup>0</sup> ≡ (∅,(), ∅, 0, π, ∅)

(64)

where [π](#page-12-0) is the set of all precompiled addresses.

6.2. Execution. We define intrinsic gas g0, the amount of gas this transaction requires to be paid prior to execution, as follows:

$$\begin{aligned} g\_0 &\equiv \sum\_{i \in T\_\mathbf{i}, T\_\mathbf{d}} \begin{cases} G\_{\text{txdatazero}} & \text{if } \quad i = 0\\ G\_{\text{txdatanonzero}} & \text{otherwise} \end{cases} \\ &+ \begin{cases} G\_{\text{txrateate}} + R(\|T\_\mathbf{i}\|) & \text{if } \quad T\_\mathbf{i} = \mathcal{D} \\ 0 & \text{otherwise} \end{cases} \\ &+ G\_{\text{transaction}} \\ &+ \sum\_{j=0}^{\|T\_\mathbf{A}\|-1} \left( G\_{\text{accessallstandness}} + \|T\_\mathbf{A}[j]\_\mathbf{s}\| \|G\_{\text{accessallstandrange}} \right) \end{aligned}$$

where Ti, T<sup>d</sup> means the series of bytes of the transaction's associated data and initialisation EVM-code, depending on whether the transaction is for contract-creation or messagecall. Gtxcreate is added if the transaction is contractcreating, but not if it is a message call. G[accesslistaddress](#page-27-5) and G[accessliststorage](#page-27-6) are the costs of warming up account and storage access, respectively. G is fully defined in Appendix [G.](#page-27-0)

<span id="page-9-1"></span>We define the initcode cost function, formally R, as the amount of gas that needs to be paid for each word of the initcode prior to executing the creation code of a new contract:

$$(65) \qquad \qquad R(x) \equiv G\_{\text{inttodewod}} \times \lceil \frac{x}{32} \rceil$$

<span id="page-9-4"></span>We define the effective gas price, formally p, as the amount of wei the transaction signer will pay per unit of gas consumed during the transaction's execution. It is calculated as follows:

$$(66) \qquad p \equiv \begin{cases} T\_{\text{P}} & \text{if } T\_{\text{X}} = 0 \lor T\_{\text{X}} = 1\\ f + H\_{\text{f}} & \text{if } T\_{\text{X}} = 2 \end{cases}$$

<span id="page-9-3"></span>where f is the priority fee—the amount of wei the block's beneficiary address will receive per unit of gas consumed during the transaction's execution. It is calculated as:

$$\text{(67)}\qquad f \equiv \begin{cases} T\_{\text{p}} - H\_{\text{f}} & \text{if } T\_{\text{x}} = 0 \lor T\_{\text{x}} = 1\\ \min\{T\_{\text{f}}, T\_{\text{m}} - H\_{\text{f}}\} & \text{if } T\_{\text{x}} = 2 \end{cases}$$

The up-front cost v<sup>0</sup> is calculated as:

$$(68) \qquad v\_0 \equiv \begin{cases} T\_\text{g} T\_\text{p} + T\_\text{v} & \text{if } T\_\text{x} = 0 \lor T\_\text{x} = 1\\ T\_\text{g} T\_\text{m} + T\_\text{v} & \text{if } T\_\text{x} = 2 \end{cases}$$

σ[S(T)]<sup>c</sup> = KEC

() ∧

<span id="page-9-0"></span>T<sup>n</sup> = σ[S(T)]<sup>n</sup> ∧ g<sup>0</sup> 6 T<sup>g</sup> ∧ v<sup>0</sup> 6 σ[S(T)]<sup>b</sup> ∧ m > H<sup>f</sup> ∧ n 6 49152 ∧ T<sup>g</sup> 6 BHl − [`](#page-2-2)(BR)<sup>u</sup>

T<sup>p</sup> if T<sup>x</sup> = 0 ∨ T<sup>x</sup> = 1

T<sup>m</sup> if T<sup>x</sup> = 2

The validity is determined as: (69) S(T) 6= ∅ ∧

(70) m ≡

where

and

$$(71) \qquad \qquad n \equiv \begin{cases} \|T\| & \text{if } T\_{\text{t}} = \mathcal{Q} \\ 0 & \text{otherwise} \end{cases}$$

(

The penultimate condition ensures that, for create transactions, the length of the initcode is no greater than 49152 bytes. Note the final condition; the sum of the transaction's gas limit, Tg, and the gas utilised in this block prior, given by [`](#page-2-2)(BR)u, must be no greater than the block's gasLimit, BHl . Also, with a slight abuse of notation, we assume that σ[S(T)]<sup>c</sup> = KEC () , σ[S(T)]<sup>n</sup> = 0, and σ[S(T)]<sup>b</sup> = 0 if σ[S(T)] = ∅.

For type 2 transactions, we add an additional check that maxPriorityFeePerGas is no larger than maxFeePer-Gas:

$$\begin{array}{c} \text{(72)} \end{array} \qquad \qquad \qquad \qquad T\_{\text{m}} \gtrless T\_{\text{f}}$$

The execution of a valid transaction begins with an irrevocable change made to the state: the [nonce of the](#page-3-2) [account of the sender,](#page-3-2) S(T), is incremented by one and the balance is reduced by part of the up-front cost, Tgp. The gas available for the proceeding computation, g, is defined as T<sup>g</sup> − g0. The computation, whether contract creation or a message call, results in an eventual state (which may legally be equivalent to the current state), the change to which is deterministic and never invalid: there can be no invalid transactions from this point.

<span id="page-9-5"></span>We define the checkpoint state σ0:

$$\begin{array}{cccc} \end{array} \text{(73)} \qquad \qquad \begin{array}{ccc} \sigma\_0 & \equiv & \sigma & \text{except:} \end{array}$$

$$\begin{array}{rcl} (74) & \quad & \sigma\_0[S(T)]\_\mathbf{b} & \equiv & \sigma[S(T)]\_\mathbf{b} - T\_\mathbf{g}p \end{array}$$

(75) σ0[S(T)]<sup>n</sup> ≡ σ[S(T)]<sup>n</sup> + 1

Evaluating σ<sup>P</sup> from σ<sup>0</sup> depends on the transaction type; either contract creation or message call; we define the tuple of post-execution provisional state σP, remaining gas g 0 , accrued substate A and status code z: (76)

$$(\sigma\_{\mathcal{P}}, g', A, z) \equiv \begin{cases} \Lambda\_4(\sigma\_0, A^\*, S(T), S(T), g, \\ p, T\_{\mathcal{V}}, T\_{\mathcal{l}}, 0, \mathcal{Q}, \top) & \text{if} \quad T\_{\mathcal{l}} = \mathcal{Q}, \\ \Theta\_4(\sigma\_0, A^\*, S(T), S(T), T\_{\mathcal{l}}, \\\ T\_{\mathcal{l}}, g, p, T\_{\mathcal{V}}, T\_{\mathcal{V}}, T\_{\mathcal{d}}, 0, \top) & \text{otherwise} \end{cases}$$

where

$$\begin{aligned} (77) \qquad &A^\* \equiv A^0 \quad \text{except} \\ (78) \qquad &A\_\mathbf{K}^\* \equiv \bigcup\_{E \in T\_\mathbf{A}} \left\{ \forall i < ||E\_\mathbf{s}||, i \in \mathbb{N} : \left(E\_\mathbf{a}, E\_\mathbf{s}[i]\right) \right\} \\ (79) \qquad &A\_\mathbf{a}^\* \equiv \begin{cases} a \cup T\_\mathbf{t} & \text{if} \quad T\_\mathbf{t} \neq \mathcal{D} \\ a & \text{otherwise} \end{cases} \end{aligned}$$

$$(80) \qquad a \equiv A\_{\mathbf{a}}^{0} \cup S(T) \cup H\_{\mathbf{c}} \cup\_{E \in T\_{\mathbf{A}}} \{E\_{\mathbf{a}}\}$$

and g is the amount of gas remaining after deducting the basic amount required to pay for the existence of the transaction:

$$\text{(81)}\tag{81}$$

$$g \equiv T\_{\text{g}} - g \text{o}$$

Note we use [Θ](#page-12-1)<sup>4</sup> and [Λ](#page-10-1)<sup>4</sup> to denote the fact that only the first four components of the functions' values are taken; the final represents the message-call's output value (a byte array) and is unused in the context of transaction evaluation.

Then the state is finalised by determining the amount to be refunded, g ∗ from the remaining gas, g 0 , plus some allowance from the refund counter, to the sender at the original rate.

$$(82) \qquad \qquad g^\* \equiv g' + \min\left\{ \left\lfloor \frac{T\_\mathrm{g} - g'}{5} \right\rfloor, A\_\mathrm{r} \right\}.$$

The total refundable amount is the legitimately remaining gas g 0 , added to [A](#page-8-1)r, with the latter component being capped up to a maximum of one fifth[9](#page-9-2) (rounded down) of the total amount used T<sup>g</sup> − g 0 . Therefore, g ∗ is the total gas that remains after the transaction has been executed.

<span id="page-9-2"></span><sup>9</sup>The max refundable proportion of gas was reduced from one half to one fifth by EIP-3529 by [Buterin and Swende](#page-17-11) [\[2021\]](#page-17-11) in the London release

∗

The validator, whose address is specified as the beneficiary of the present block B, receives the gas consumed multiplied by the transaction's priority fee per gas, defined as [f](#page-9-3) in this section. The ether that is paid by the transactor that goes toward the base fee is debited from the transactor's account but credited to no other account, so it is burned.

We define the pre-final state σ ∗ in terms of the provisional state σP:

$$\begin{array}{ccccc}(83) & \sigma^\* & \equiv & \sigma\_\mathrm{P} & \mathrm{except} \\ (84) & \sigma^\*[S(T)]\_\mathrm{b} & \equiv & \sigma\_\mathrm{P}[S(T)]\_\mathrm{b} + g^\*p \\ (85) & \sigma^\*[B\_\mathrm{H}]\_\mathrm{b} & \equiv & \sigma\_\mathrm{P}[B\_\mathrm{H}]\_\mathrm{b} + (T\_\mathrm{g} - g^\*)f \end{array}$$

The final state, σ 0 , is reached after deleting all accounts that either appear in the self-destruct set or are touched and empty:

$$\begin{array}{ccccc}(86) & & \sigma' & \equiv & \sigma^\* & \text{except} \\ (87) & & \forall i \in A\_{\sf s} : \sigma'[i] & = & \mathcal{Q} \\ (88) & & \forall i \in A\_{\sf t} : \sigma'[i] & = & \mathcal{Q} & \text{if} & \textsf{DEAD}(\sigma^\*,i) \end{array}$$

<span id="page-10-0"></span>And finally, we specify Υ<sup>g</sup> , the total gas used in this transaction Υ<sup>l</sup> , the logs created by this transaction and Υ z , the status code of this transaction:

$$\begin{array}{cccc} \text{(89)} & & \text{T}^{\text{g}}(\sigma, T) & \equiv & T\_{\text{g}} - g^\* \\ \end{array}$$

$$(90) \qquad \qquad \Upsilon^{\mathrm{I}}(\sigma, T) \quad \equiv \quad A\_{\mathrm{I}}$$

Υ z (91) (σ, T) ≡ z

These are used to help define the [transaction receipt](#page-5-4) and are also used [later](#page-16-2) for state validation.

### <span id="page-10-3"></span>7. Contract Creation

There are a number of intrinsic parameters used when creating an account: sender (s), original transactor[10](#page-10-2) (o), available gas (g), effective gas price (p), endowment (v) together with an arbitrary length byte array, i, the initialisation EVM code, the present depth of the messagecall/contract-creation stack (e), the salt for new account's address (ζ) and finally the permission to make modifications to the state (w). The salt ζ might be missing (ζ = ∅); formally,

$$(92) \qquad \qquad \qquad \zeta \in \mathbb{B}\_{32} \cup \mathbb{B}\_{0}$$

If the creation was caused by [CREATE2](#page-38-1), then ζ 6= ∅.

<span id="page-10-1"></span>We define the creation function formally as the function Λ, which evaluates from these values, together with the state σ and the accrued substate A, to the tuple containing the new state, remaining gas, new accrued substate, status code and output (σ 0 , g<sup>0</sup> , A<sup>0</sup> , z, o):

$$(93)\qquad(\sigma',g',A',z,\mathbf{o}) \equiv \Lambda(\sigma,A,s,o,g,p,v,\mathbf{i},e,\zeta,w)$$

The address of the new account is defined as being the rightmost 160 bits of the Keccak-256 hash of the [RLP](#page-19-3) encoding of the structure containing only the sender and the [account nonce.](#page-3-2) For [CREATE2](#page-38-1) the rule is different and is described in EIP-1014 by [Buterin \[2018\]](#page-17-12). Combining the two cases, we define the resultant address for the new account a:

$$(94) \qquad \qquad a \equiv \mathsf{ADDR}(s, \sigma[s]\_\mathbf{n} - 1, \zeta, \mathbf{i})$$

<span id="page-10-4"></span>
$$\mathbf{c}(95) \quad \mathsf{ADDR}(s, n, \zeta, \mathbf{i}) \equiv \mathcal{B}\_{96\dots255} \left( \mathsf{KEC} \left( L\_{\Lambda} \left( s, n, \zeta, \mathbf{i} \right) \right) \right)$$

$$\text{(96)}\qquad L\_{\text{A}}(s, n, \zeta, \mathbf{i}) \equiv \begin{cases} \text{RLP} \left( \left. \left( s, n \right) \right. \right) & \text{if } \zeta = \varpi \\ \text{(255)} \cdot s \cdot \zeta \cdot \mathbf{KEC(\mathbf{i})} & \text{otherwise} \end{cases}$$

where · is the concatenation of byte arrays, Ba..b(X) evaluates to a binary value containing the bits of indices in the range [a, b] of the binary data X, and σ[x] is the address state of x, or ∅ if none exists. Note we use one fewer than the sender's nonce value; we assert that we have incremented the sender account's nonce prior to this call, and so the value used is the sender's nonce at the beginning of the responsible transaction or VM operation.

The address of the new account is added to the set of accessed accounts:

$$(97) \qquad \qquad A^\* \equiv A \quad \text{except} \quad A\_\mathbf{a}^\* \equiv A\_\mathbf{a} \cup \{a\}$$

The account's nonce is initially defined as one, the balance as the value passed, the storage as empty and the code hash as the Keccak 256-bit hash of the empty string; the sender's balance is also reduced by the value passed. Thus the mutated state becomes σ ∗ :

$$(98) \qquad \qquad \qquad \qquad \sigma^\* \equiv \sigma \quad \text{except:} \tag{86}$$

$$(99)\qquad \sigma^\*[a]\quad =\quad \left(1, v+v', \text{TRUE}(\mathcal{D}), \text{KEC}(()\right)\right)$$

$$(100)\quad\sigma^\*[s]\quad = \begin{cases} \mathcal{Q} & \text{if } \sigma[s] = \mathcal{Q} \land \ v = 0\\ \mathbf{a}^\* & \text{otherwise} \end{cases}$$

$$(101) \qquad \mathbf{a}^\* \quad \equiv \quad (\sigma[s]\_\mathbf{n}, \sigma[s]\_\mathbf{b} - v, \sigma[s]\_\mathbf{s}, \sigma[s]\_\mathbf{c})$$

where v 0 is the account's pre-existing value, in the event it was previously in existence:

$$(102) \qquad \qquad v' \equiv \begin{cases} 0 & \text{if} \quad \sigma[a] = \mathcal{D} \\ \sigma[a]\_\text{b} & \text{otherwise} \end{cases}$$

Finally, the account is initialised through the execution of the initialising EVM code i according to the execution model (see section [9\)](#page-12-2). Code execution can effect several events that are not internal to the execution state: the account's storage can be altered, further accounts can be created and further message calls can be made. As such, the code execution function [Ξ](#page-13-0) evaluates to a tuple of the resultant state σ ∗∗, available gas remaining g ∗∗, the resultant accrued substate A ∗∗ and the body code of the account o.

$$(103)\qquad(\sigma^{\*\*}, g^{\*\*}, A^{\*\*}, \mathbf{o}) \equiv \Xi(\sigma^{\*}, g, A^{\*}, I)$$

where I contains the parameters of the [execution environ](#page-13-1)[ment,](#page-13-1) that is:

<span id="page-10-2"></span><sup>10</sup>which can differ from the sender in the case of a message call or contract creation not directly triggered by a transaction but coming from the execution of EVM-code

| SHANGHAI VERSIC |  |
|-----------------|--|
|                 |  |

| (104) | Ia | ≡ | a  |
|-------|----|---|----|
| (105) | Io | ≡ | o  |
| (106) | Ip | ≡ | p  |
| (107) | Id | ≡ | () |
| (108) | Is | ≡ | s  |
| (109) | Iv | ≡ | v  |
| (110) | Ib | ≡ | i  |
| (111) | Ie | ≡ | e  |
| (112) | Iw | ≡ | w  |

I<sup>d</sup> evaluates to the empty tuple as there is no input data to this call. I<sup>H</sup> has no special treatment and is determined from the blockchain.

Code execution depletes gas, and gas may not go below zero, thus execution may exit before the code has come to a natural halting state. In this (and several other) exceptional cases we say an out-of-gas (OOG) exception has occurred: The evaluated state is defined as being the empty set, ∅, and the entire create operation should have no effect on the state, effectively leaving it as it was immediately prior to attempting the creation.

If the initialization code completes successfully, a final contract-creation cost is paid, the code-deposit cost, c, proportional to the size of the created contract's code:

$$\begin{array}{cc} \text{(113)} & c \equiv G\_{\text{codedopost}} \times \|\mathbf{o}\| \, \end{array} \tag{311}$$

If there is not enough gas remaining to pay this, i.e. g ∗∗ < c, then we also declare an out-of-gas exception.

The gas remaining will be zero in any such exceptional condition, i.e. if the creation was conducted as the reception of a transaction, then this doesn't affect payment of the intrinsic cost of contract creation; it is paid regardless. However, the value of the transaction is not transferred to the aborted contract's address when we are out-of-gas, thus the contract's code is not stored.

If such an exception does not occur, then the remaining gas is refunded to the originator and the now-altered state is allowed to persist. Thus formally, we may specify the resultant state, gas, accrued substate and status code as (σ 0 , g<sup>0</sup> , A<sup>0</sup> , z) where:

$$(114)$$

$$g' \equiv \begin{cases} 0 & \text{if} \quad F \\ g^{\star\star} - c & \text{otherwise} \end{cases}$$
 (115)

$$\sigma' \equiv \begin{cases} \sigma & \text{if} \quad F \lor \sigma^{\star\star} = \mathcal{B} \\ \sigma^{\star\star} & \text{except} \end{cases}$$
 
$$\sigma' \equiv \begin{cases} \sigma'[a] = \mathcal{D} & \text{if} \quad \mathsf{DEAD}(\sigma^{\star\star}, a) \\ \sigma^{\star\star} & \text{except} \end{cases}$$
 (116)

$$A' \equiv \begin{cases} A^\* & \text{if} \quad F \lor \sigma^{\star\star} = \mathcal{B} \\ A^{\*\star} & \text{otherwise} \end{cases}$$
 (117)

$$z \equiv \begin{cases} 0 & \text{if} \quad F \lor \sigma^{\star\star} = \mathcal{B} \\ 1 & \text{otherwise} \end{cases}$$
 
$$\text{where}$$
 
$$\text{where}$$
 
$$\mathcal{B} \text{ is a vector space of order } \mathcal{B} \text{ given by}$$

$$\begin{array}{rcl} ^{\star\prime}F \equiv \left( \sigma[a] \not\equiv \mathcal{Q} \ \wedge & \left( \sigma[a] \not\equiv \text{xEC} \{ () \right) \vee \sigma[a] \!\vert\_{n} \neq 0 \rangle \right) & \vee\\ (\sigma^{\star\ast} = \mathcal{Q} \ \wedge & \mathbf{o} = \mathcal{Q}) & \vee\\ g^{\star\ast} < c & \vee & \end{array}$$

$$\begin{aligned} \|\mathbf{o}\| &> 24576 \quad \lor \\ \mathbf{o}[0] &= \mathbf{0} \mathbf{x} \mathbf{e} \mathbf{f} \\\\ \text{Note the last condition of } F \text{ indicates that contract.} \end{aligned}$$

<span id="page-11-1"></span>Note the last condition of F indicates that contract code cannot begin with the byte 0xef (refer to EIP-3541 by [Beregszaszi et al. \[2021\]](#page-17-13)),

The exception in the determination of σ <sup>0</sup> dictates that o, the resultant byte sequence from the execution of the initialisation code, specifies the final body code for the newly-created account.

Note that intention is that the result is either a successfully created new contract with its endowment, or no new contract with no transfer of value. In addition, observe that if the execution of the initialising code [reverts](#page-38-2) (σ ∗∗ = ∅ ∧ o 6= ∅), the resultant gas g 0 is not depleted (provided there was no other exception), but no new account is created.

7.1. Subtleties. Note that while the initialisation code is executing, the newly created address exists but with no intrinsic body code[11](#page-11-0). Thus any message call received by it during this time causes no code to be executed. If the initialisation execution ends with a SELFDESTRUCT instruction, the matter is moot since the account will be deleted before the transaction is completed. For a normal STOP code, or if the code returned is otherwise empty, then the state is left with a zombie account, and any remaining balance will be locked into the account forever.

### 8. Message Call

In the case of executing a message call, several parameters are required: sender (s), transaction originator (o), recipient (r), the account whose code is to be executed

<span id="page-11-0"></span><sup>11</sup>During initialization code execution, EXTCODESIZE on the address should return zero, which is the length of the code of the account while CODESIZE should return the length of the initialization code (as defined in [H.2\)](#page-29-0).

(c, usually the same as recipient), available gas (g), value (v) and effective gas price (p) together with an arbitrary length byte array, d, the input data of the call, the present depth of the message-call/contract-creation stack (e) and finally the permission to make modifications to the state (w).

Aside from evaluating to a new state and accrued transaction substate, message calls also have an extra component—the output data denoted by the byte array o. This is ignored when executing transactions, however message calls can be initiated due to VM-code execution and in this case this information is used.

<span id="page-12-1"></span>
$$\begin{aligned} (119)\\ (\sigma', g', A', z, \mathbf{o}) \equiv \Theta(\sigma, A, s, o, r, c, g, p, v, \bar{v}, \mathbf{d}, e, w) \end{aligned} $$

Note that we need to differentiate between the value that is to be transferred, v, from the value apparent in the execution context, v˜, for the DELEGATECALL instruction.

We define σ1, the first transitional state as the original state but with the value transferred from sender to recipient:

$$(120) \qquad \sigma\_1[r]\_\mathbf{b} \equiv \sigma[r]\_\mathbf{b} + v \quad \land \quad \sigma\_1[s]\_\mathbf{b} \equiv \sigma[s]\_\mathbf{b} - v$$

unless s = r.

Throughout the present work, it is assumed that if σ1[r] was originally undefined, it will be created as an account with no code or state and zero balance and nonce. Thus the previous equation should be taken to mean:

$$\begin{array}{cc} \text{(121)} & \sigma\_1 \equiv \sigma\_1' & \text{except:} \\ \end{array}$$

$$(122) \qquad \sigma\_1[s] \equiv \begin{cases} \mathcal{Q} & \text{if } \sigma\_1'[s] = \mathcal{Q} \land \ v = 0\\ \mathbf{a}\_1 & \text{otherwise} \end{cases}$$

$$\begin{pmatrix} \end{pmatrix} \begin{aligned} \mathbf{a}\_1 &\equiv \begin{pmatrix} \sigma\_1'[s]\_\mathbf{n}, \sigma\_1'[s]\_\mathbf{b} - v, \sigma\_1'[s]\_\mathbf{s}, \sigma\_1'[s]\_\mathbf{c} \end{pmatrix} \end{aligned}$$

$$\begin{array}{cccc} \text{(124)} & & \text{and} & \sigma\_1' \equiv \sigma & \text{except:} \end{array}$$

$$\begin{cases} \text{(125)}\\ \begin{cases} \sigma'\_1[r] \equiv (0, v, \text{TRIE}(\mathcal{Q}), \text{KEC}(\text{()})) & \text{if} \quad \sigma[r] = \mathcal{Q} \wedge v \neq 0\\ \sigma'\_1[r] \equiv \mathcal{Q} & \text{if} \quad \sigma[r] = \mathcal{Q} \wedge v = 0\\ \sigma'\_1[r] \equiv \mathbf{a}'\_1 & \text{otherwise} \end{cases} \end{cases}$$

$$(126)\qquad \mathbf{a}'\_1 \equiv (\sigma[r]\_\mathbf{n}, \sigma[r]\_\mathbf{b} + v, \sigma[r]\_\mathbf{a}, \sigma[r]\_\mathbf{c})$$

The account's associated code (identified as the fragment whose Keccak-256 hash is σ[c]c) is executed according to the execution model (see section [9\)](#page-12-2). Just as with contract creation, if the execution halts in an exceptional fashion (i.e. due to an exhausted gas supply, stack underflow, invalid jump destination or invalid instruction), then no gas is refunded to the caller and the state is reverted to the point immediately prior to balance transfer (i.e. σ).

$$\begin{array}{rcl} \text{(127)} & & \sigma' & \equiv & \begin{cases} \sigma & \text{if} & \sigma^{\ast \ast} = \mathcal{Q} \\ \sigma^{\ast \ast} & \text{otherwise} \end{cases} \end{array}$$

$$\begin{array}{rclcrcl} \text{(128)} & & g' & \equiv & \begin{cases} 0 & \text{if } & \sigma^{\dashv \ast} = \varpi \wedge \neg \\ & & \mathbf{o} = \varpi \\ g^{\dashv \ast} & \text{otherwise} \end{cases} \\\\ \text{(129)} & & A' & \equiv & \begin{cases} A & \text{if } & \sigma^{\dashv \ast} = \varpi \\ & \cdots & \cdots & \cdots \end{cases} \end{array}$$

$$\begin{array}{ccccc} & & & & \\ & & & & \\ \text{(130)} & & & & z & \end{array} \begin{cases} A^{\*\*} & \text{otherwise} \\ 0 & \text{if } & \sigma^{\*\*} = \mathcal{Q} \\ 1 & \text{otherwise} \end{cases}$$

<span id="page-12-3"></span>
$$\begin{array}{ccccc}(131)(\sigma^{\leftrightarrow\,},g^{\leftrightarrow\,},A^{\leftrightarrow\,},\mathbf{o})&\equiv&\Xi\\(132)&I\_{\mathbf{a}}&\equiv&r\\(133)&I\_{\mathbf{o}}&\equiv&o\\(134)&I\_{\mathbf{p}}&\equiv&p\\(135)&I\_{\mathbf{d}}&\equiv&\mathbf{d}\\(136)&I\_{\mathbf{s}}&\equiv&s\\(137)&I\_{\mathbf{v}}&\equiv&\bar{v}\\(138)&I\_{\mathbf{e}}&\equiv&e\\(139)&I\_{\mathbf{w}}&\equiv&w\end{array}$$

where

$$(140) \qquad \qquad \Xi \equiv \begin{cases} \Xi\_{\text{ECEC}}(\sigma\_1, g, A, I) & \text{if} \quad c = 1 \\ \Xi\_{\text{SE4256}}(\sigma\_1, g, A, I) & \text{if} \quad c = 2 \\ \Xi\_{\text{EP160}}(\sigma\_1, g, A, I) & \text{if} \quad c = 3 \\ \Xi\_{\text{ID}}(\sigma\_1, g, A, I) & \text{if} \quad c = 4 \\ \Xi\_{\text{EP400}}(\sigma\_1, g, A, I) & \text{if} \quad c = 5 \\ \Xi\_{\text{EM400}}(\sigma\_1, g, A, I) & \text{if} \quad c = 6 \\ \Xi\_{\text{EM401}}(\sigma\_1, g, A, I) & \text{if} \quad c = 7 \\ \Xi\_{\text{EM425}}(\sigma\_1, g, A, I) & \text{if} \quad c = 8 \\ \Xi\_{\text{EL422}}(\sigma\_1, g, A, I) & \text{if} \quad c = 9 \\ \Xi(\sigma\_1, g, A, I) & \text{otherwise} \end{cases} (140)$$

and

$$\text{(141)}\qquad\qquad\qquad\qquad\text{KEC}(I\_{\mathbf{b}})=\sigma[c]\_{\mathcal{C}}$$

It is assumed that the client will have stored the pair (KEC(Ib), Ib) at some point prior in order to make the determination of I<sup>b</sup> feasible.

As can be seen, there are nine exceptions to the usage of the general execution framework Ξ for evaluation of the message call: these are so-called 'precompiled' contracts, meant as a preliminary piece of architecture that may later become native extensions. The contracts in addresses 1 to 9 execute the elliptic curve public key recovery function, the SHA2 256-bit hash scheme, the RIPEMD 160-bit hash scheme, the identity function, arbitrary precision modular exponentiation, elliptic curve addition, elliptic curve scalar multiplication, an elliptic curve pairing check, and the BLAKE2 compression function F respectively. Their full formal definition is in Appendix [E.](#page-21-0) We denote the set of the addresses of the precompiled contracts by π:

<span id="page-12-2"></span>
$$\begin{array}{c} \text{(142)} \qquad \qquad \pi \equiv \{1, 2, 3, 4, 5, 6, 7, 8, 9\} \end{array}$$

### <span id="page-12-0"></span>9. Execution Model

The execution model specifies how the system state is altered given a series of bytecode instructions and a small tuple of environmental data. This is specified through a formal model of a virtual state machine, known as the Ethereum Virtual Machine (EVM). It is a quasi-Turingcomplete machine; the quasi qualification comes from the fact that the computation is intrinsically bounded through a parameter, gas, which limits the total amount of computation done.

9.1. Basics. The EVM is a simple stack-based architecture. The word size of the machine (and thus size of stack items) is 256-bit. This was chosen to facilitate the Keccak-256 hash scheme and elliptic-curve computations. The memory model is a simple word-addressed byte array. The stack has a maximum size of 1024. The machine also has an independent storage model; this is similar in concept to the memory but rather than a byte array, it is a wordaddressable word array. Unlike memory, which is volatile, storage is non volatile and is maintained as part of the system state. All locations in both storage and memory are well-defined initially as zero.

The machine does not follow the standard von Neumann architecture. Rather than storing program code in generally-accessible memory or storage, it is stored separately in a virtual ROM interactable only through a specialised instruction.

The machine can have exceptional execution for several reasons, including stack underflows and invalid instructions. Like the out-of-gas exception, they do not leave state changes intact. Rather, the machine halts immediately and reports the issue to the execution agent (either the transaction processor or, recursively, the spawning execution environment) which will deal with it separately.

9.2. Fees Overview. Fees (denominated in gas) are charged under three distinct circumstances, all three as prerequisite to the execution of an operation. The first and most common is the fee intrinsic to the computation of the operation (see Appendix [G\)](#page-27-0). Secondly, gas may be deducted in order to form the payment for a subordinate message call or contract creation; this forms part of the payment for CREATE, CREATE2, CALL and CALLCODE. Finally, gas may be paid due to an increase in the usage of the memory.

Over an account's execution, the total fee for memoryusage payable is proportional to smallest multiple of 32 bytes that are required such that all memory indices (whether for read or write) are included in the range. This is paid for on a just-in-time basis; as such, referencing an area of memory at least 32 bytes greater than any previously indexed memory will certainly result in an additional memory usage fee. Due to this fee it is highly unlikely addresses will ever go above 32-bit bounds. That said, implementations must be able to manage this eventuality.

Storage fees have a slightly nuanced behaviour—to incentivise minimisation of the use of storage (which corresponds directly to a larger state database on all nodes), the execution fee for an operation that clears an entry in the storage is not only waived, a qualified refund is given; in fact, this refund is effectively paid up-front since the initial usage of a storage location costs substantially more than normal usage.

See Appendix [H](#page-27-8) for a rigorous definition of the EVM gas cost.

<span id="page-13-1"></span>9.3. Execution Environment. In addition to the system state σ, the remaining gas for computation g, and the accrued substate A, there are several pieces of important information used in the execution environment that the execution agent must provide; these are contained in the tuple I:

- Ia, the address of the account which owns the code that is executing.
- Io, the sender address of the transaction that originated this execution.
- Ip, the price of gas paid by the signer of the transaction that originated this execution. This is defined as the effective gas price [p](#page-9-4) in section [6.](#page-8-0)
- <span id="page-13-4"></span>• Id, the byte array that is the input data to this execution; if the execution agent is a transaction, this would be the transaction data.
- Is, the address of the account which caused the code to be executing; if the execution agent is a transaction, this would be the transaction sender.
- <span id="page-13-2"></span>• Iv, the value, in Wei, passed to this account as part of the same procedure as execution; if the execution agent is a transaction, this would be the transaction value.
- Ib, the byte array that is the machine code to be executed.
- IH, the block header of the present block.
- Ie, the depth of the present message-call or contract-creation (i.e. the number of CALLs or CREATE(2)s being executed at present).
- Iw, the permission to make modifications to the state.

The execution model defines the function Ξ, which can compute the resultant state σ 0 , the remaining gas g 0 , the resultant accrued substate A 0 and the resultant output, o, given these definitions. For the present context, we will define it as:

$$(143)\qquad\qquad(\sigma',g',A',\mathbf{o})\equiv\Xi(\sigma,g,A,I)$$

where we will remember that A, the accrued substate, is defined in section [6.1.](#page-8-3)

<span id="page-13-0"></span>9.4. Execution Overview. We must now define the Ξ function. In most practical implementations this will be modelled as an iterative progression of the pair comprising the full system state, σ and the machine state, µ. Formally, we define it recursively with a function X. This uses an iterator function O (which defines the result of a single cycle of the state machine) together with functions [Z](#page-14-0) which determines if the present state is an [exceptional](#page-14-0) [halting](#page-14-0) state of the machine and [H](#page-15-3), specifying the output data of the instruction if and only if the present state is a [normal halting](#page-15-3) state of the machine.

<span id="page-13-3"></span>The empty sequence, denoted (), is not equal to the empty set, denoted ∅; this is important when interpreting the output of H, which evaluates to ∅ when execution is to continue but a series (potentially empty) when execution should halt.

$$\begin{array}{llll}(144) & \Xi(\sigma, g, A, I) & \equiv & (\sigma', \mu'\_{\mathfrak{g}}, A', \mathfrak{o})\\(145) & (\sigma', \mu', A', \dots, \mathfrak{o}) & \equiv & X\{(\sigma, \mu, A, I)\}\\(146) & & \mu\_{\mathfrak{g}} & \equiv & g\\(147) & & \mu\_{\mathrm{pc}} & \equiv & 0\\(148) & & \mu\_{\mathrm{m}} & \equiv & (0, 0, \dots)\end{array}$$

$$\begin{array}{ccccc} \text{(149)} & & & \mu\_{\text{l}} & \equiv & 0 \\ \text{(149)} & & & & \mu\_{\text{l}} & \equiv & 0 \\ \end{array}$$

$$\begin{array}{rcl} \text{(150)} & & \mu\_{\mathfrak{s}} & \equiv & 0 \end{array}$$

$$\begin{array}{ccccc}\text{(151)} & & & \mu\_{\bullet} & \equiv & 0\\\end{array}$$

(152)

<span id="page-14-1"></span>
$$X\left(\left(\sigma,\mu,A,I\right)\right) \equiv \begin{cases} \left(\mathcal{Q},\mu,A,I,\mathcal{Q}\right) & \text{if} \quad Z\left(\sigma,\mu,A,I\right) \\ \left(\mathcal{Q},\mu',A,I,\mathbf{o}\right) & \text{if} \quad w = \text{REVER} \\ O\left(\sigma,\mu,A,I\right)\cdot\mathbf{o} & \text{if} \quad \mathbf{o} \neq \mathcal{Q} \\ X\left(O\left(\sigma,\mu,A,I\right)\right) & \text{otherwise} \end{cases}$$

where

$$\begin{array}{rcl}(153) & \mathbf{o} & \equiv & H(\mu, I) \\ (154) & = & (a, b, c, d) \cdot e & \equiv & (a, b, c, d, e) \end{array}$$

$$\begin{array}{rcl} \text{(155)} & & \mu' & \equiv & \mu \text{ except:} \end{array}$$

µ 0 (156) <sup>g</sup> ≡ µ<sup>g</sup> − C(σ, µ, A, I)

Note that, when we evaluate Ξ, we drop the fourth element I 0 and extract the remaining gas µ 0 g from the resultant machine state µ 0 .

X is thus cycled (recursively here, but implementations are generally expected to use a simple iterative loop) until either [Z](#page-14-0) becomes true indicating that the present state is exceptional and that the machine must be halted and any changes discarded or until [H](#page-15-3) becomes a series (rather than the empty set) indicating that the machine has reached a controlled halt.

9.4.1. Machine State. The machine state µ is defined as the tuple (g, pc, m, i, s, o) which are the gas available, the program counter pc ∈ N<sup>256</sup> , the memory contents, the active number of words in memory (counting continuously from position 0), the stack contents, and the returndata buffer. The memory contents µ<sup>m</sup> are a series of zeroes of size 2<sup>256</sup> .

For the ease of reading, the instruction mnemonics, written in small-caps (e.g. ADD), should be interpreted as their numeric equivalents; the full table of instructions and their specifics is given in Appendix [H.](#page-27-8)

For the purposes of defining Z, H and O, we define w as the current operation to be executed:

$$(157) \qquad w \equiv \begin{cases} I\_{\mathbf{b}}[\mu\_{\mathrm{pc}}] & \text{if} \quad \mu\_{\mathrm{pc}} < \|I\_{\mathbf{b}}\| \\ \mathrm{STOP} & \text{otherwise} \end{cases}$$

We also assume the fixed amounts of δ and α, specifying the stack items removed and added, both subscriptable on the instruction and an instruction cost function C evaluating to the full cost, in gas, of executing the given instruction.

<span id="page-14-0"></span>9.4.2. Exceptional Halting. The exceptional halting function Z is defined as:

$$\begin{array}{rcl} (158) & \\ Z(\sigma,\mu,A,I) \equiv & \mu\_g < C(\sigma,\mu,A,I) \quad \lor \\ & \delta\_w = \mathcal{D} \quad \lor \\ & \|\mu\_\mathbf{s}\| < \delta\_w \quad \lor \\ & (w = \text{JUMP} \land \mu\_\mathbf{s}[0] \notin D(I\_\mathbf{b})) \quad \lor \\ & (w = \text{JUMP} \land \mu\_\mathbf{s}[0] \notin D(I\_\mathbf{b})) \quad \lor \\ & \mu\_\mathbf{s}[0] \notin D(I\_\mathbf{b})) \quad \lor \\ & (w = \text{RETURN} \land \text{ATACOPY} \land \\ & \mu\_\mathbf{s}[1] + \mu\_\mathbf{s}[2] > ||\mu\_\mathbf{o}[1] \quad \lor \\ & ||\mu\_\mathbf{s}|| - \delta\_w + \alpha\_w > 1024 \quad \lor \\ & (\neg I\_\mathbf{v} \land W(w,\mu)) \quad \lor \\ & (w = \text{SSTORE} \land \mu\_\mathbf{g} \lessgtr G\_\mathbf{call} \text{span}) \end{array}$$

where

$$\begin{array}{rcl}(159) \ W(w,\mu) \equiv & w \in \{\text{CREATE, CREATE2, SSTORE}, \\ & \text{SELFDESTRUT} \right\rangle \vee\\ & \text{LOG} 0 \le w \wedge w \le \text{LOG} 4 \quad \vee\\ & w = \text{CALL} \wedge \mu\_{\mathfrak{s}}[2] \neq 0 \end{array}$$

This states that the execution is in an exceptional halting state if there is insufficient gas, if the instruction is invalid (and therefore its δ subscript is undefined), if there are insufficient stack items, if a JUMP/JUMPI destination is invalid, the new stack size would be larger than 1024 or state modification is attempted during a static call. The astute reader will realise that this implies that no instruction can, through its execution, cause an exceptional halt. Also, the execution is in an exceptional halting state if the gas left prior to executing an [SSTORE](#page-34-1) instruction is less than or equal to the call stipend G[callstipend](#page-27-9) – see EIP-2200 by [Tang \[2019\]](#page-18-9) for more information.

9.4.3. Jump Destination Validity. We previously used D as the function to determine the set of valid jump destinations given the code that is being run. We define this as any position in the code occupied by a JUMPDEST instruction.

All such positions must be on valid instruction boundaries, rather than sitting in the data portion of PUSH operations and must appear within the explicitly defined portion of the code (rather than in the implicitly defined [STOP](#page-30-0) operations that trail it).

Formally:

$$\begin{array}{cc} \text{(160)} & \text{ } & D(\mathbf{c}) \equiv D\_{\mathbf{J}}(\mathbf{c}, 0) \\ \end{array}$$

where: (161)

$$D\_{\mathsf{J}}(\mathbf{c},i) \equiv \begin{cases} \{\} & \text{if } \quad i \geqslant \|\mathbf{c}\| \\ \{i\} \cup D\_{\mathsf{J}}(\mathbf{c}, N(i, \mathbf{c}[i])) \\ & \text{if } \quad \mathbf{c}[i] = \text{JUMPDEST} \\ D\_{\mathsf{J}}(\mathbf{c}, N(i, \mathbf{c}[i])) & \text{otherwise} \end{cases}$$

where N is the next valid instruction position in the code, skipping the data of a PUSH instruction, if any: (162)

$$N(i, w) \equiv \begin{cases} i + w - \text{PUSH1} + 2\\ \text{if } \quad w \in [\text{PUSH1}, \text{PUSH32}]\\ i + 1 & \text{otherwise} \end{cases}$$

<span id="page-15-3"></span>9.4.4. Normal Halting. The normal halting function H is defined:

$$(163)$$

$$H(\mu, I) \equiv \begin{cases} H\_{\text{RETURN}}(\mu) \text{ if } & w \in \{\text{RETURN}, \text{REVERT}\} \\ \text{()} & \text{if } \quad w \in \{\text{STOP}, \text{SELFDESTRVUT}\} \\ \mathcal{D} & \text{otherwise} \end{cases}$$

The data-returning halt operations, [RETURN](#page-37-0) and REVERT, have a special function HRETURN. Note also the difference between the empty sequence and the empty set as discussed [here.](#page-13-3)

9.5. The Execution Cycle. Stack items are added or removed from the left-most, lower-indexed portion of the series; all other items remain unchanged:

$$\begin{array}{rcl}(164) & \quad & O\left((\sigma,\mu,A,I)\right) & \equiv & (\sigma',\mu',A',I) \end{array}$$

$$\begin{array}{ccccc}\text{(165)} & & \Delta & \equiv & \alpha\_w - \delta\_w \\\end{array}$$

$$\begin{array}{rcl} \text{(166)} & & \|\mu\_{\mathsf{s}}'\| & \equiv & \|\mu\_{\mathsf{s}}\| + \Delta \\ \end{array}$$

$$(167) \quad \forall x \in [\alpha\_w, ||\mu'\_{\mathfrak{s}}||): \mu'\_{\mathfrak{s}}[x] \quad \equiv \quad \mu\_{\mathfrak{s}}[x - \Delta]$$

The gas is reduced by the instruction's gas cost and for most instructions, the program counter increments on each cycle, for the three exceptions, we assume a function J, subscripted by one of two instructions, which evaluates to the according value:

$$\begin{array}{rcl} \text{(168)} & \mu'\_{\text{g}} & \equiv & \mu\_{\text{g}} - C(\sigma, \mu, A, I) \\\\ \text{(169)} & \mu'\_{\text{pc}} & \equiv & \begin{cases} J\_{\text{JUMP}}(\mu) & \text{if} & w = \text{JUMP} \\ J\_{\text{JUMPI}}(\mu) & \text{if} & w = \text{JUMPI} \\ N(\mu\_{\text{pc}}, w) & \text{otherwise} \end{cases} \end{array}$$

In general, we assume the memory, accrued substate and system state do not change:

$$\begin{array}{ccccc}\text{(170)} & & & \mu'\_{\text{m}} & \equiv & \mu\_{\text{m}}\\\end{array}$$

$$\begin{array}{ccccc}\text{(171)} & & & \mu\_{\text{l}}' & \equiv & \mu\_{\text{l}} \\\end{array}$$

$$\begin{array}{ccccc} \text{(172)} & & & A' & \equiv & A \\ \end{array}$$

$$\begin{array}{cccc} \end{array} \begin{array}{ccc} \sigma' & \equiv & \sigma \\ \end{array}$$

However, instructions do typically alter one or several components of these values. Altered components listed by instruction are noted in Appendix [H,](#page-27-8) alongside values for α and δ and a formal description of the gas requirements.

### 10. Transition to Proof of Stake

<span id="page-15-2"></span>The Paris hard fork changed the underlying consensus mechanism of Ethereum from proof of work to proof of stake.

Unlike all previous hard forks of Ethereum, Paris was not defined to occur at a particular block height, but rather after a specified terminal total difficulty was reached. Total difficulty was used instead of block height to avoid a scenario in which a minority of hash power could create a malicious fork that could race to satisfy the block height requirement and claim the first proof of stake block.

Thus the terminal block, the last proof of work block before the Paris fork takes effect, is defined as having:

(174) B<sup>t</sup> > 58750000000000000000000

$$\begin{array}{cccc} \text{(175)} & P(B\_{\text{H}})\_{\text{t}} & < & 587500000000000000000000 \\ \text{(176)} & & & 509999999999999999999999 \end{array}$$

where B<sup>t</sup> is the total difficulty of block B and P(BH)<sup>t</sup> is the total difficulty of its parent.

Total difficulty for a proof of work (pre-Paris) block B is defined recursively as:

$$\begin{array}{rcl}(176) & & B\_{\rm t} & \equiv & P(B\_{\rm H})\_{\rm t} + H\_{\rm d} \end{array}$$

where H<sup>d</sup> is the difficulty of the current block B.

Upon reaching the terminal block, new blocks are processed by the Beacon Chain.

10.1. Post-Paris Updates. Because the Beacon Chain generate a new slot every 12 seconds, post-Paris updates can be scheduled to occur at a specific timestamp. At the execution layer, the update will then happen in the first produced block after the scheduled timestamp. For example the Shanghai hard fork was scheduled to occur at 2023-04-12 10:27:35 UTC, on Epoch 194,048. Validators failed to propose a block during the two first slots of this Epoch, but at slot 6,209,538 a validator finally proposed the block 17,034,870, marking the transition to Shanghai on the execution layer.

### 11. Blocktree to Blockchain

<span id="page-15-1"></span>Prior to the transition to proof of stake at the Paris hard fork, the canonical blockchain was defined as the block path with the greatest total difficulty, defined in section [10](#page-15-2) as Bt.

After reaching the terminal block described in section [10,](#page-15-2) the greatest total difficulty rule must be removed in favor of a rule known as LMD Ghost. [12](#page-15-4)

Note that in order to determine what blocks comprise the canonical Ethereum blockchain after Paris, one must have additional information from the Beacon Chain, which is not described herein. We denote events emitted by the Beacon Chain with the prefix POS .

On each occurrence of a POS FORKCHOICE UPDATED event, starting with the first at the transition block described in section [10,](#page-15-2) the canonical chain is defined as the chain beginning with the genesis block and ending at the block nominated by the event as the head of the chain.

The head of the chain should be updated if and only if a POS FORKCHOICE UPDATED is emitted, in which case the head should set to the block specified by the event. No optimistic updates to the head of the chain should be made.

The POS FORKCHOICE UPDATED event additionally references a finalized block. The most recent finalized block should be set to this block.

The canonical blockchain must also contain a block with the hash and number of the terminal block defined in section [10.](#page-15-2)

### 12. Block Finalisation

<span id="page-15-0"></span>The process of finalising a block involves three stages:

- (1) executing withdrawals;
- (2) validate transactions;
- (3) verify state.

<span id="page-15-4"></span><sup>12</sup>LMD GHOST comprises two acronyms, "Latest Message Driven", and "Greedy Heaviest-Observed Sub-Tree".

12.1. Executing Withdrawals. After processing the block's transactions, the withdrawals are executed. A withdrawal is simply an increase of the recipient account's balance of the specified Gwei amount. No other balances are decreased, a withdrawal is not a transfer but a creation of funds. A withdrawal operation cannot fail and has no gas cost. We define the function E as the withdrawal state transition function:

$$\begin{array}{cccc}(177) & E(\sigma\_w, W) & \equiv & \sigma\_{w+1} \\ (178) & & \sigma\_{w+1} & \equiv & \sigma\_w & \text{except:}\end{array}$$

$$(179) \quad \sigma\_{w+1} [W\_r]\_\mathbf{b} \quad \equiv \quad \sigma\_w [W\_r]\_\mathbf{b} + (W\_a \times 10^9)$$

<span id="page-16-3"></span>Finally, we define K, the block-level state transition function for withdrawals:

$$(180)\qquad K(\sigma, B) \equiv E(E(\sigma, W\_0), W\_1)\dots$$

12.2. Transaction Validation. The given gasUsed must correspond faithfully to the transactions listed: [B](#page-5-11)Hg, the total gas used in the block, must be equal to the accumulated gas used according to the final transaction:

$$\text{(181)}\qquad\qquad\qquad\qquad B\_{\text{Hg}} = \ell(\mathbf{R})\_{\text{u}}$$

<span id="page-16-1"></span>12.3. State Validation. We may now define the function, Γ, that maps a block B to its initiation state: (182)

$$\Gamma(B) \equiv \begin{cases} \sigma\_0 & \text{if } \quad P(B\_\mathcal{H}) = \mathcal{D} \\ \sigma\_\perp : \text{TRIE}(L\_\mathcal{S}(\sigma\_\perp)) = P(B\_\mathcal{H})\_{\mathcal{H}\_\mathcal{F}} & \text{otherwise} \end{cases}$$

Here, TRIE(LS(σi)) means the hash of the root node of a trie of state σi; it is assumed that implementations will store this in the state database, which is trivial and efficient since the trie is by nature an immutable data structure.

And finally we define Φ, the block transition function, which maps an incomplete block B to a complete block B 0 :

$$(183)\quad\Phi(B)\quad\equiv\quad B':\quad B'=B\quad\text{except:}$$

$$\begin{array}{rcl} (184) & B\_{\text{H}\_{\text{F}}}^{\prime} & = & \mathsf{TREE} (L\_{\text{S}} (K (\Pi (\Gamma (B), B), B))) \end{array}$$

As specified at the beginning of the present work, [Π](#page-16-0) is the state-transition function, which is defined in terms of [Υ,](#page-1-0) the transaction-evaluation function.

As previously detailed, R[n]z, R[n]<sup>l</sup> and R[n]<sup>u</sup> are the nth corresponding status code, logs and cumulative gas used after each transaction (R[n]b, the fourth component in the tuple, has already been defined in terms of the logs). We also define the nth state σ[n], which is defined simply as the state resulting from applying the corresponding transaction to the state resulting from the previous transaction (or the block's initial state in the case of the first such transaction):

<span id="page-16-2"></span>
$$\begin{aligned} (185) \qquad \qquad \sigma[n] = \begin{cases} \Gamma(B) & \text{if} \quad n < 0\\ \Upsilon(\sigma[n-1], B\pi[n]) & \text{otherwise} \end{cases} \end{aligned}$$

In the case of BR[n]u, we take a similar approach defining each item as the gas used in evaluating the corresponding transaction summed with the previous item (or zero, if it is the first), giving us a running total:

$$\mathbf{R}(186) \qquad \mathbf{R}[n]\_\mathbf{u} = \begin{cases} 0 & \text{if} \quad n < 0 \\ \Upsilon^g(\sigma[n-1], B\_\mathbf{T}[n]) & \\ \ + \mathbf{R}[n-1]\_\mathbf{u} & \text{otherwise} \end{cases}$$

For R[n]l, we utilise the [Υ](#page-10-0)<sup>l</sup> function that we conveniently defined in the transaction execution function.

$$(187) \qquad \qquad \mathbf{R}[n]\_\mathbf{l} = \Upsilon^\mathbf{l}(\sigma[n-1], B\_\mathbf{T}[n])$$

We define [R](#page-10-0)[n]<sup>z</sup> in a similar manner.

$$\begin{pmatrix} 188 \end{pmatrix} \qquad \qquad \mathbf{R}[n]\_{\mathbf{z}} = \Upsilon^{\mathbf{z}}(\sigma[n-1], B\_{\mathbf{T}}[n])$$

<span id="page-16-0"></span>Finally, we define Π as the final transaction's resultant state, [`](#page-2-2)(σ):

$$\text{(189)}\qquad\qquad\qquad\text{II}(\sigma, B)\equiv\ell(\sigma)$$

Thus the complete block-transition mechanism (before consensus) is defined.

### 13. Implementing Contracts

There are several patterns of contracts engineering that allow particular useful behaviours; two of these that we will briefly discuss are data feeds and random numbers.

13.1. Data Feeds. A data feed contract is one which provides a single service: it gives access to information from the external world within Ethereum. The accuracy and timeliness of this information is not guaranteed and it is the task of a secondary contract author—the contract that utilises the data feed—to determine how much trust can be placed in any single data feed.

The general pattern involves a single contract within Ethereum which, when given a message call, replies with some timely information concerning an external phenomenon. An example might be the local temperature of New York City. This would be implemented as a contract that returned that value of some known point in storage. Of course this point in storage must be maintained with the correct such temperature, and thus the second part of the pattern would be for an external server to run an Ethereum node, and immediately on discovery of a new block, creates a new valid transaction, sent to the contract, updating said value in storage. The contract's code would accept such updates only from the identity contained on said server.

13.2. Random Numbers. Providing random numbers within a deterministic system is, naturally, an impossible task. However, we can approximate with pseudo-random numbers by utilising data which is generally unknowable at the time of transacting. Such data might include the block's hash and the block's beneficiary address. In order to make it hard for malicious validators to control those values, one should use the [BLOCKHASH](#page-33-0) operation in order to use hashes of the previous 256 blocks as pseudo-random numbers. For a series of such numbers, a trivial solution would be to add some constant amount and hashing the result.

### 14. Future Directions

The state database won't be forced to maintain all past state [trie](#page-20-1) structures into the future. It should maintain an age for each node and eventually discard nodes that are neither recent enough nor checkpoints. Checkpoints, or a set of nodes in the database that allow a particular block's state trie to be traversed, could be used to place a maximum limit on the amount of computation needed in order to retrieve any state throughout the blockchain.

Blockchain consolidation could be used in order to reduce the amount of blocks a client would need to download

to act as a full node. A compressed archive of the trie structure at given points in time (perhaps one in every 10,000th block) could be maintained by the peer network, effectively recasting the [genesis block.](#page-38-0) This would reduce the amount to be downloaded to a single archive plus a hard maximum limit of blocks.

Finally, blockchain compression could perhaps be conducted: nodes in state trie that haven't sent/received a transaction in some constant amount of blocks could be thrown out, reducing both Ether-leakage and the growth of the state database.

### 15. Conclusion

We have introduced, discussed and formally defined the protocol of Ethereum. Through this protocol the reader may implement a node on the Ethereum network and join others in a decentralised secure social operating system. Contracts may be authored in order to algorithmically specify and autonomously enforce rules of interaction.

### 16. Acknowledgements

Many thanks to Aeron Buchanan for authoring the Homestead revisions, Christoph Jentzsch for authoring the Ethash algorithm and Yoichi Hirai for doing most of the EIP-150 changes. Important maintenance, useful corrections and suggestions were provided by a number of others from the Ethereum DEV organisation and Ethereum community at large including Gustav Simonsson, Pawe l Bylica, Jutta Steiner, Nick Savers, Viktor Tr´on, Marko Simovic, Giacomo Tazzari and, of course, Vitalik Buterin.

### 17. Availability

The source of this paper is maintained at [https:](https://github.com/ethereum/yellowpaper/) [//github.com/ethereum/yellowpaper/](https://github.com/ethereum/yellowpaper/). An autogenerated PDF is located at [https://ethereum.github.](https://ethereum.github.io/yellowpaper/paper.pdf) [io/yellowpaper/paper.pdf](https://ethereum.github.io/yellowpaper/paper.pdf).

#### References

- <span id="page-17-3"></span>Jacob Aron. BitCoin software finds new life. New Scientist, 213(2847):20, 2012. URL [http://www.sciencedirect.](http://www.sciencedirect.com/science/article/pii/S0262407912601055) [com/science/article/pii/S0262407912601055](http://www.sciencedirect.com/science/article/pii/S0262407912601055).
- <span id="page-17-2"></span>Adam Back. Hashcash - Amortizable Publicly Auditable Cost-Functions, 2002. URL [http://www.hashcash.org/](http://www.hashcash.org/papers/amortizable.pdf) [papers/amortizable.pdf](http://www.hashcash.org/papers/amortizable.pdf).
- <span id="page-17-13"></span>Alex Beregszaszi, Pawe l Bylica, Andrei Maiboroda, Alexey Akhunov, Christian Reitwiessner, and Martin Swende. EIP-3541: Reject new contract code starting with the 0xef byte, March 2021. URL [https://eips.ethereum.](https://eips.ethereum.org/EIPS/eip-3541) [org/EIPS/eip-3541](https://eips.ethereum.org/EIPS/eip-3541).
- <span id="page-17-6"></span>Guido Bertoni, Joan Daemen, Michal Peeters, and Gilles Van Assche. The KECCAK SHA-3 submission, 2011. URL [https://keccak.team/files/](https://keccak.team/files/Keccak-submission-3.pdf) [Keccak-submission-3.pdf](https://keccak.team/files/Keccak-submission-3.pdf).
- <span id="page-17-4"></span>Roman Boutellier and Mareike Heinzen. Pirates, Pioneers, Innovators and Imitators. In Growth Through Innovation, pages 85–96. Springer, 2014. URL [https:](https://www.springer.com/gb/book/9783319040158) [//www.springer.com/gb/book/9783319040158](https://www.springer.com/gb/book/9783319040158).
- <span id="page-17-0"></span>Vitalik Buterin. Ethereum: A Next-Generation Smart Contract and Decentralized Application Platform, 2013. URL [https://github.com/ethereum/wiki/](https://github.com/ethereum/wiki/wiki/White-Paper) [wiki/White-Paper](https://github.com/ethereum/wiki/wiki/White-Paper).
- <span id="page-17-18"></span>Vitalik Buterin. EIP-2: Homestead hard-fork changes, 2015. URL <https://eips.ethereum.org/EIPS/eip-2>.
- <span id="page-17-5"></span>Vitalik Buterin. EIP-155: Simple replay attack protection, October 2016. URL [https://eips.ethereum.org/](https://eips.ethereum.org/EIPS/eip-155) [EIPS/eip-155](https://eips.ethereum.org/EIPS/eip-155).
- <span id="page-17-12"></span>Vitalik Buterin. EIP-1014: Skinny CREATE2, April 2018. URL <https://eips.ethereum.org/EIPS/eip-1014>.
- <span id="page-17-10"></span>Vitalik Buterin and Martin Swende. EIP-2929: Gas cost increases for state access opcodes, September 2020a. URL <https://eips.ethereum.org/EIPS/eip-2929>.
- <span id="page-17-7"></span>Vitalik Buterin and Martin Swende. EIP-2930: Optional access lists, August 2020b. URL [https://eips.ethereum.](https://eips.ethereum.org/EIPS/eip-2930) [org/EIPS/eip-2930](https://eips.ethereum.org/EIPS/eip-2930).
- <span id="page-17-11"></span>Vitalik Buterin and Martin Swende. EIP-3529: Reduction in refunds, April 2021. URL [https://eips.ethereum.](https://eips.ethereum.org/EIPS/eip-3529) [org/EIPS/eip-3529](https://eips.ethereum.org/EIPS/eip-3529).
- <span id="page-17-8"></span>Vitalik Buterin, Eric Conner, Rick Dudley, Matthew Slipper, Ian Norden, and Abdelhamid Bakhta. EIP-1559: Fee market change for eth 1.0 chain, 2019. URL <https://eips.ethereum.org/EIPS/eip-1559>.
- <span id="page-17-15"></span>Nicolas T. Courtois, Marek Grajek, and Rahul Naik. Optimizing SHA256 in Bitcoin Mining, pages 131– 144. Springer Berlin Heidelberg, Berlin, Heidelberg, 2014. ISBN 978-3-662-44893-9. doi: 10. 1007/978-3-662-44893-9 12. URL [https://doi.org/10.](https://doi.org/10.1007/978-3-662-44893-9_12) [1007/978-3-662-44893-9\\_12](https://doi.org/10.1007/978-3-662-44893-9_12).
- <span id="page-17-21"></span>B.A. Davey and H.A. Priestley. Introduction to lattices and order. 2nd ed. Cambridge: Cambridge University Press, 2nd ed. edition, 2002. ISBN 0-521-78451-4/pbk.
- <span id="page-17-1"></span>Cynthia Dwork and Moni Naor. Pricing via processing or combatting junk mail. In In 12th Annual International Cryptology Conference, pages 139– 147, 1992. URL [http://www.wisdom.weizmann.ac.il/](http://www.wisdom.weizmann.ac.il/~naor/PAPERS/pvp.pdf) [~naor/PAPERS/pvp.pdf](http://www.wisdom.weizmann.ac.il/~naor/PAPERS/pvp.pdf).
- <span id="page-17-9"></span>Dankrad Feist, Dmitry Khovratovich, and Marius van der Wijden. EIP-3607: Reject transactions from senders with deployed code, June 2021. URL [https://eips.](https://eips.ethereum.org/EIPS/eip-3607) [ethereum.org/EIPS/eip-3607](https://eips.ethereum.org/EIPS/eip-3607).
- <span id="page-17-20"></span>Phong Vo Glenn Fowler, Landon Curt Noll. FowlerNollVo hash function, 1991. URL [http://www.isthe.com/](http://www.isthe.com/chongo/tech/comp/fnv/index.html) [chongo/tech/comp/fnv/index.html](http://www.isthe.com/chongo/tech/comp/fnv/index.html).
- <span id="page-17-16"></span>Nils Gura, Arun Patel, Arvinderpal Wander, Hans Eberle, and Sheueling Chang Shantz. Comparing elliptic curve cryptography and RSA on 8-bit CPUs. In Cryptographic Hardware and Embedded Systems-CHES 2004, pages 119–132. Springer, 2004. URL [https://www.iacr.org/](https://www.iacr.org/archive/ches2004/31560117/31560117.pdf) [archive/ches2004/31560117/31560117.pdf](https://www.iacr.org/archive/ches2004/31560117/31560117.pdf).
- <span id="page-17-14"></span>Tjaden Hess, Matt Luongo, Piotr Dyraga, and James Hancock. EIP-152: Add BLAKE2 compression function 'F' precompile, October 2016. URL [https://eips.](https://eips.ethereum.org/EIPS/eip-152) [ethereum.org/EIPS/eip-152](https://eips.ethereum.org/EIPS/eip-152).
- <span id="page-17-17"></span>Don Johnson, Alfred Menezes, and Scott Vanstone. The Elliptic Curve Digital Signature Algorithm (ECDSA), 2001. URL [https:](https://web.archive.org/web/20170921160141/http://cs.ucsb.edu/~koc/ccs130h/notes/ecdsa-cert.pdf) [//web.archive.org/web/20170921160141/http://](https://web.archive.org/web/20170921160141/http://cs.ucsb.edu/~koc/ccs130h/notes/ecdsa-cert.pdf) [cs.ucsb.edu/~koc/ccs130h/notes/ecdsa-cert.pdf](https://web.archive.org/web/20170921160141/http://cs.ucsb.edu/~koc/ccs130h/notes/ecdsa-cert.pdf). Accessed 21 September 2017, but the original link was inaccessible on 19 October 2017. Refer to section 6.2 for ECDSAPUBKEY, and section 7 for ECDSASIGN and ECDSARECOVER.
- <span id="page-17-19"></span>Sergio Demian Lerner. Strict Memory Hard Hashing Functions, 2014. URL [http://www.hashcash.org/papers/](http://www.hashcash.org/papers/memohash.pdf) [memohash.pdf](http://www.hashcash.org/papers/memohash.pdf).
- <span id="page-18-6"></span>Mark Miller. The Future of Law. In paper delivered at the Extro 3 Conference (August 9), 1997. URL [https://drive.google.com/file/d/](https://drive.google.com/file/d/0Bw0VXJKBgYPMS0J2VGIyWWlocms/edit?usp=sharing) [0Bw0VXJKBgYPMS0J2VGIyWWlocms/edit?usp=sharing](https://drive.google.com/file/d/0Bw0VXJKBgYPMS0J2VGIyWWlocms/edit?usp=sharing).
- <span id="page-18-1"></span>Satoshi Nakamoto. Bitcoin: A peer-to-peer electronic cash system, 2008. URL [http://www.bitcoin.org/bitcoin.](http://www.bitcoin.org/bitcoin.pdf) [pdf](http://www.bitcoin.org/bitcoin.pdf).
- <span id="page-18-4"></span>Meni Rosenfeld, Yoni Assia, Vitalik Buterin, m liorhakiLior, Oded Leiba, Assaf Shomer, and Eliran Zach. Colored Coins Protocol Specification, 2012. URL [https://github.com/Colored-Coins/](https://github.com/Colored-Coins/Colored-Coins-Protocol-Specification) [Colored-Coins-Protocol-Specification](https://github.com/Colored-Coins/Colored-Coins-Protocol-Specification).
- <span id="page-18-10"></span>Markku-Juhani Saarinen and Jean-Philippe Aumasson. RFC 7693: The BLAKE2 cryptographic hash and message authentication code (MAC), November 2015. URL <https://tools.ietf.org/html/rfc7693>.
- <span id="page-18-2"></span>Simon Sprankel. Technical Basis of Digital Currencies, 2013. URL [http://www.coderblog.de/wp-content/](http://www.coderblog.de/wp-content/uploads/technical-basis-of-digital-currencies.pdf)

[uploads/technical-basis-of-digital-currencies.](http://www.coderblog.de/wp-content/uploads/technical-basis-of-digital-currencies.pdf) [pdf](http://www.coderblog.de/wp-content/uploads/technical-basis-of-digital-currencies.pdf).

- <span id="page-18-5"></span>Nick Szabo. Formalizing and securing relationships on public networks. First Monday, 2(9), 1997. URL [http://firstmonday.org/ojs/index.php/](http://firstmonday.org/ojs/index.php/fm/article/view/548) [fm/article/view/548](http://firstmonday.org/ojs/index.php/fm/article/view/548).
- <span id="page-18-9"></span>Wei Tang. EIP-2200: Structured definitions for net gas metering, 2019. URL [https://eips.ethereum.org/EIPS/](https://eips.ethereum.org/EIPS/eip-2200) [eip-2200](https://eips.ethereum.org/EIPS/eip-2200).
- <span id="page-18-0"></span>Vivek Vishnumurthy, Sangeeth Chandrakumar, and Emin Gn Sirer. KARMA: A secure economic framework for peer-to-peer resource sharing, 2003. URL [https://](https://www.cs.cornell.edu/people/egs/papers/karma.pdf) [www.cs.cornell.edu/people/egs/papers/karma.pdf](https://www.cs.cornell.edu/people/egs/papers/karma.pdf).
- <span id="page-18-3"></span>J. R. Willett. MasterCoin Complete Specification, 2013. URL <https://github.com/mastercoin-MSC/spec>.
- <span id="page-18-8"></span>Micah Zoltu. EIP-2718: Typed transaction envelope, June 2020. URL [https://eips.ethereum.org/EIPS/](https://eips.ethereum.org/EIPS/eip-2718) [eip-2718](https://eips.ethereum.org/EIPS/eip-2718).

### Appendix A. Terminology

- <span id="page-18-7"></span>External Actor: A person or other entity able to interface to an Ethereum node, but external to the world of Ethereum. It can interact with Ethereum through depositing signed Transactions and inspecting the blockchain and associated state. Has one (or more) intrinsic Accounts.
- Address: A 160-bit code used for identifying Accounts.
- Account: Accounts have an intrinsic balance and transaction count maintained as part of the Ethereum state. They also have some (possibly empty) EVM Code and a (possibly empty) Storage State associated with them. Though homogenous, it makes sense to distinguish between two practical types of account: those with empty associated EVM Code (thus the account balance is controlled, if at all, by some external entity) and those with non-empty associated EVM Code (thus the account represents an Autonomous Object). Each Account has a single Address that identifies it.
- Transaction: A piece of data, signed by an External Actor. It represents either a Message or a new Autonomous Object. Transactions are recorded into each block of the blockchain.
- Autonomous Object: A notional object existent only within the hypothetical state of Ethereum. Has an intrinsic address and thus an associated account; the account will have non-empty associated EVM Code. Incorporated only as the Storage State of that account.
- Storage State: The information particular to a given Account that is maintained between the times that the Account's associated EVM Code runs.
- Message: Data (as a set of bytes) and Value (specified as Ether) that is passed between two Accounts, either through the deterministic operation of an Autonomous Object or the cryptographically secure signature of the Transaction.
- Message Call: The act of passing a message from one Account to another. If the destination account is associated with non-empty EVM Code, then the VM will be started with the state of said Object and the Message acted upon. If the message sender is an Autonomous Object, then the Call passes any data returned from the VM operation.
- Gas: The fundamental network cost unit. Paid for exclusively by Ether (as of PoC-4), which is converted freely to and from Gas as required. Gas does not exist outside of the internal Ethereum computation engine; its price is set by the Transaction and validators are free to ignore Transactions whose Gas price is too low.
- Contract: Informal term used to mean both a piece of EVM Code that may be associated with an Account or an Autonomous Object.
- Object: Synonym for Autonomous Object.
- App: An end-user-visible application hosted in the Ethereum Browser.
- Ethereum Browser: (aka Ethereum Reference Client) A cross-platform GUI of an interface similar to a simplified browser (a la Chrome) that is able to host sandboxed applications whose backend is purely on the Ethereum protocol.
- Ethereum Virtual Machine: (aka EVM) The virtual machine that forms the key part of the execution model for an Account's associated EVM Code.
- Ethereum Runtime Environment: (aka ERE) The environment which is provided to an Autonomous Object executing in the EVM. Includes the EVM but also the structure of the world state on which the EVM relies for certain I/O instructions including CALL & CREATE.
- EVM Code: The bytecode that the EVM can natively execute. Used to formally specify the meaning and ramifications of a message to an Account.
- EVM Assembly: The human-readable form of EVM-code.

LLL: The Lisp-like Low-level Language, a human-writable language used for authoring simple contracts and general low-level language toolkit for trans-compiling to.

### Appendix B. Recursive Length Prefix

<span id="page-19-3"></span><span id="page-19-0"></span>This is a serialisation method for encoding arbitrarily structured binary data (byte arrays). We define the set of possible structures T:

$$\begin{array}{ccccc}\text{(190)} & & & \mathbb{T} & \equiv & \mathbb{L} \oplus \mathbb{B} \\\end{array}$$

(191) L ≡ {t : t = (t[0], t[1], ...) ∧ ∀n < ktk : t[n] ∈ T}

(192) B ≡ {b : b = (b[0], b[1], ...) ∧ ∀n < kbk : b[n] ∈ O}

Where O is the set of (8-bit) bytes. Thus B is the set of all sequences of bytes (otherwise known as byte arrays, and a leaf if imagined as a tree), L is the set of all tree-like (sub-)structures that are not a single leaf (a branch node if imagined as a tree) and T is the set of all byte arrays and such structural sequences. The disjoint union ] is needed only to distinguish the empty byte array () ∈ B from the empty list () ∈ L, which are encoded differently as defined below; as common, we will abuse notation and leave the disjoint union indices implicit, inferable from context.

We define the RLP function as RLP through two sub-functions, the first handling the instance when the value is a byte array, the second when it is a sequence of further values:

$$\text{(193)}\tag{193} \qquad \qquad \qquad \qquad \qquad \text{RLP}(\mathbf{x}) \equiv \begin{cases} R\_{\text{b}}(\mathbf{x}) & \text{if} \quad \mathbf{x} \in \mathbb{B} \\ R\_{\text{l}}(\mathbf{x}) & \text{otherwise} \end{cases}$$

If the value to be serialised is a byte array, the RLP serialisation takes one of three forms:

- If the byte array contains solely a single byte and that single byte is less than 128, then the input is exactly equal to the output.
- If the byte array contains fewer than 56 bytes, then the output is equal to the input prefixed by the byte equal to the length of the byte array plus 128.
- Otherwise, the output is equal to the input, provided that it contains fewer than 2<sup>64</sup> bytes, prefixed by the minimal-length byte array which when interpreted as a big-endian integer is equal to the length of the input byte array, which is itself prefixed by the number of bytes required to faithfully encode this length value plus 183.

Byte arrays containing 2<sup>64</sup> or more bytes cannot be encoded. This restriction ensures that the first byte of the encoding of a byte array is always below 192, and thus it can be readily distinguished from the encodings of sequences in L.

<span id="page-19-4"></span><span id="page-19-2"></span>Formally, we define Rb:

$$\begin{array}{rclcrcl} & & & R\_{\mathtt{b}}(\mathtt{x}) & \equiv & \begin{cases} \mathtt{x} & & \text{if } & \|\mathtt{x}\| = 1 \land \mathtt{x}[0] < 128\\ (128 + \|\mathtt{x}\|) \cdot \mathtt{x} & & \text{else if } & \|\mathtt{x}\| < 56\\ (183 + \|\mathtt{B}\underline{\mathtt{C}}(\|\mathtt{x}\|)) \| \cdot \mathtt{B}\underline{\mathtt{C}}(\|\mathtt{x}\|) \cdot \mathtt{x} & \text{else if } & \|\mathtt{x}\| < 2^{64}\\ \mathcal{Q} & & \text{otherwise} \end{array} \end{array} \end{array} \tag{19}$$

$$\begin{array}{rcl} \mathsf{AE}(x) & \equiv & (b\_0, b\_1, \ldots): b\_0 \neq 0 \land x = \sum\_{n=0}^{\|\mathbf{b}\|-1} b\_n \cdot 256^{\|\mathbf{b}\|-1-n} \end{array}$$

$$(196) \qquad \qquad (x\_1, \ldots, x\_n) \cdot (y\_1, \ldots, y\_m) \quad = \quad (x\_1, \ldots, x\_n, y\_1, \ldots, y\_m)$$

Thus BE is the function that expands a non-negative integer value to a big-endian byte array of minimal length and the dot operator performs sequence concatenation.

If instead, the value to be serialised is a sequence of other items then the RLP serialisation takes one of two forms:

- If the concatenated serialisations of each contained item is less than 56 bytes in length, then the output is equal to that concatenation prefixed by the byte equal to the length of this byte array plus 192.
- Otherwise, the output is equal to the concatenated serialisations, provided that they contain fewer than 2<sup>64</sup> bytes, prefixed by the minimal-length byte array which when interpreted as a big-endian integer is equal to the length of the concatenated serialisations byte array, which is itself prefixed by the number of bytes required to faithfully encode this length value plus 247.

Sequences whose concatenated serialized items contain 2<sup>64</sup> or more bytes cannot be encoded. This restriction ensures that the first byte of the encoding does not exceed 255 (otherwise it would not be a byte).

<span id="page-19-1"></span>Thus we finish by formally defining Rl:

$$(197) \qquad \qquad R(\mathbf{x}) \equiv \begin{cases} (192 + \|s(\mathbf{x})\|) \cdot s(\mathbf{x}) & \text{if } \quad s(\mathbf{x}) \neq \mathcal{D} \land \|s(\mathbf{x})\| < 56\\ \left(247 + \left\|\operatorname{BE}(\|s(\mathbf{x})\|) \right\|\right) \cdot \operatorname{BE}(\|s(\mathbf{x})\|) \cdot s(\mathbf{x}) & \text{else if } \quad s(\mathbf{x}) \neq \mathcal{D} \land \|s(\mathbf{x})\| < 2^{64}\\ \mathcal{D} & \text{otherwise} \end{cases}$$

$$\begin{array}{rcl} s(198) & \equiv & \begin{cases} \text{RLP}(\mathbf{x}[0]) \cdot \text{RLP}(\mathbf{x}[1]) \cdot \dots & \text{if} \quad \forall i: \text{RLP}(\mathbf{x}[i]) \neq \mathcal{Q} \\ \mathcal{Q} & \text{otherwise} \end{cases} \end{array}$$

If RLP is used to encode a scalar, defined only as a non-negative integer (in N, or in N<sup>x</sup> for any x), it must be encoded as the shortest byte array whose big-endian interpretation is the scalar. Thus the RLP of some non-negative integer i is defined as:

$$(199) \tag{199}$$

$$\mathsf{RLP}(i:i \in \mathbb{N}) \equiv \mathsf{RLP}(\mathsf{RE}(i))$$

When interpreting RLP data, if an expected fragment is decoded as a scalar and leading zeroes are found in the byte sequence, clients are required to consider it non-canonical and treat it in the same manner as otherwise invalid RLP data, dismissing it completely.

There is no specific canonical encoding format for signed or floating-point values.

### <span id="page-20-2"></span>Appendix C. Hex-Prefix Encoding

Hex-prefix encoding is an efficient method of encoding an arbitrary number of nibbles as a byte array. It is able to store an additional flag which, when used in the context of the trie (the only context in which it is used), disambiguates between node types.

It is defined as the function HP which maps from a sequence of nibbles (represented by the set Y) together with a boolean value to a sequence of bytes (represented by the set B):

$$(200) \qquad \mathsf{HP}(\mathbf{x}, t) : \mathbf{x} \in \mathsf{Y} \quad \equiv \begin{cases} (16f(t), 16\mathbf{x}[0] + \mathbf{x}[1], 16\mathbf{x}[2] + \mathbf{x}[3], \dots) & \text{if } \|\mathbf{x}\| \text{ is even} \\ (16(f(t) + 1) + \mathbf{x}[0], 16\mathbf{x}[1] + \mathbf{x}[2], 16\mathbf{x}[3] + \mathbf{x}[4], \dots) & \text{otherwise} \end{cases}$$
 
$$f(t) \quad \equiv \begin{cases} 2 & \text{if } \ t \neq 0 \\ 0 & \text{otherwise} \end{cases}$$

Thus the high nibble of the first byte contains two flags; the lowest bit encoding the oddness of the length and the second-lowest encoding the flag t. The low nibble of the first byte is zero in the case of an even number of nibbles and the first nibble in the case of an odd number. All remaining nibbles (now an even number) fit properly into the remaining bytes.

### Appendix D. Modified Merkle Patricia Tree

<span id="page-20-1"></span><span id="page-20-0"></span>The modified Merkle Patricia tree (trie) provides a persistent data structure to map between arbitrary-length binary data (byte arrays). It is defined in terms of a mutable data structure to map between 256-bit binary fragments and arbitrary-length binary data, typically implemented as a database. The core of the trie, and its sole requirement in terms of the protocol specification, is to provide a single value that identifies a given set of key-value pairs, which may be either a 32-byte sequence or the empty byte sequence. It is left as an implementation consideration to store and maintain the structure of the trie in a manner that allows effective and efficient realisation of the protocol.

Formally, we assume the input value I, a set containing pairs of byte sequences with unique keys:

$$\mathfrak{(202)} \qquad \qquad \mathfrak{I} = \{ (\mathbf{k}\_0 \in \mathbb{B}, \mathbf{v}\_0 \in \mathbb{B}), (\mathbf{k}\_1 \in \mathbb{B}, \mathbf{v}\_1 \in \mathbb{B}), \ldots \} $$

When considering such a sequence, we use the common numeric subscript notation to refer to a tuple's key or value, thus:

$$(203) \tag{203}$$
 
$$\forall I: \mathfrak{I} \in \mathfrak{I}: I \equiv (I\_0, I\_1)$$

Any series of bytes may also trivially be viewed as a series of nibbles, given an endian-specific notation; here we assume big-endian. Thus:

$$\begin{array}{rcl} (204) & & & y(\Im) & = & \{ (\mathbf{k}\_0' \in \mathbb{Y}, \mathbf{v}\_0 \in \mathbb{B}), (\mathbf{k}\_1' \in \mathbb{Y}, \mathbf{v}\_1 \in \mathbb{B}), \ldots \} \end{array}$$

$$\begin{array}{rcl} \text{(205)} & & \forall n: & \forall i < 2 \|\mathbf{k}\_n\|: & \mathbf{k}'\_n[i] & \equiv & \begin{cases} \lfloor \mathbf{k}\_n[i \div 2] \div 16 \rfloor & \text{if } i \text{ is even} \\ \mathbf{k}\_n[\lfloor i \div 2 \rfloor] \bmod 16 & \text{otherwise} \end{cases} \end{array}$$

We define the function TRIE, which evaluates to the root of the trie that represents this set when encoded in this structure:

$$\mathbf{(206)}\tag{206}$$

$$\mathbf{(207)}\mathbf{(207)}\equiv\mathbf{(207)}\mathbf{(207)}$$

We also assume a function n, the trie's node cap function. When composing a node, we use RLP to encode the structure. As a means of reducing storage complexity, we store nodes whose composed RLP is fewer than 32 bytes directly; for those larger we assert prescience of the byte array whose Keccak-256 hash evaluates to our reference. Thus we define in terms of c, the node composition function:

$$(\text{207}) \qquad \qquad n(\mathfrak{I}, i) \equiv \begin{cases} () \in \mathbb{B} & \text{if } \quad \mathfrak{I} = \mathfrak{D} \\ c(\mathfrak{I}, i) & \text{if } \quad \|\, \text{RLP}\left(c(\mathfrak{I}, i)\right)\| < 32 \\ \text{KEC}\left(\text{RLP}\left(c(\mathfrak{I}, i)\right)\right) & \text{otherwise} \end{cases}$$

In a manner similar to a radix tree, when the trie is traversed from root to leaf, one may build a single key-value pair. The key is accumulated through the traversal, acquiring a single nibble from each branch node (just as with a radix tree). Unlike a radix tree, in the case of multiple keys sharing the same prefix or in the case of a single key having a unique

suffix, two optimising nodes are provided. Thus while traversing, one may potentially acquire multiple nibbles from each of the other two node types, extension and leaf. There are three kinds of nodes in the trie:

- Leaf: A two-item structure whose first item corresponds to the nibbles in the key not already accounted for by the accumulation of keys and branches traversed from the root. The hex-prefix encoding method is used and the second parameter to the function is required to be 1.
- Extension: A two-item structure whose first item corresponds to a series of nibbles of size greater than one that are shared by at least two distinct keys past the accumulation of the keys of nibbles and the keys of branches as traversed from the root. The hex-prefix encoding method is used and the second parameter to the function is required to be 0.
- Branch: A 17-item structure whose first sixteen items correspond to each of the sixteen possible nibble values for the keys at this point in their traversal. The 17th item is used in the case of this being a terminator node and thus a key being ended at this point in its traversal.

A branch is then only used when necessary; no branch nodes may exist that contain only a single non-zero entry. We may formally define this structure with the structural composition function c:

$$(208)\quad c(\Im,i) \equiv \begin{cases} \{\mathsf{HP}(I\_0[i..([\![l\![ 0\!]-1]\!],1\!),I\_1) & \text{if } & \|\Im\| = 1 \quad \text{where } \exists I:I \in \Im\\ \{\mathsf{HP}(I\_0[i..(j-1)],0),n(\Im,j)\} & \text{if } & i \neq j \quad \text{where } j = \max\{x:\exists!:([1] = x \land \forall I \in \Im:I\_0[0..(x-1)]=1\})\\ (u(0),u(1),\ldots,u(15),v) & \text{otherwise} \quad \text{where } u(j) \equiv & n(\{I:I\in\Im \land I\_0[i]=j\},i+1)\\ & & v = \begin{cases} I\_1 & \text{if } & \exists I:I \in \Im \land I\_0 \|i\| = i\\ I\_2 & \text{otherwise} \end{cases} \end{cases}$$

D.1. Trie Database. Thus no explicit assumptions are made concerning what data is stored and what is not, since that is an implementation-specific consideration; we simply define the identity function mapping the key-value set I to a 32-byte hash and assert that only a single such hash exists for any I, which though not strictly true is accurate within acceptable precision given the Keccak hash's collision resistance. In reality, a sensible implementation will not fully recompute the trie root hash for each set.

A reasonable implementation will maintain a database of nodes determined from the computation of various tries or, more formally, it will memoise the function c. This strategy uses the nature of the trie to both easily recall the contents of any previous key-value set and to store multiple such sets in a very efficient manner. Due to the dependency relationship, Merkle-proofs may be constructed with an O(log N) space requirement that can demonstrate a particular leaf must exist within a trie of a given root hash.

### <span id="page-21-2"></span>Appendix E. Precompiled Contracts

<span id="page-21-0"></span>For each precompiled contract, we make use of a template function, ΞPRE, which implements the out-of-gas checking.

$$(209) \qquad \qquad \qquad \Xi\_{\mathsf{PRE}}(\sigma, g, A, I) \equiv \begin{cases} (\mathcal{D}, 0, A, (\rangle) & \text{if} \quad g < g\_{\mathsf{P}} \\ (\sigma, g - g\_{\mathsf{P}}, A, \mathbf{o}) & \text{otherwise} \end{cases}$$

The precompiled contracts each use these definitions and provide specifications for the o (the output data) and gr, the gas requirements.

We define ΞECREC as a precompiled contract for the elliptic curve digital signature algorithm (ECDSA) public key recovery function (ecrecover). See Appendix [F](#page-25-0) for the definition of the function ECDSARECOVER and the constant secp256k1n. We also define d to be the input data, well-defined for an infinite length by appending zeroes as required. In the case of an invalid signature, we return no output.

<span id="page-21-1"></span>
$$\begin{array}{cccc} \text{(210)} & & & \Xi\_{\text{ECREC}} & \equiv & \Xi\_{\text{RE}} & \text{where:}\\\end{array}$$

$$\begin{array}{cccc}\text{(211)} & & & & & \\ \text{(211)} & & & & & \\ \end{array}$$

$$(212) \qquad \qquad \|\mathbf{o}\|\| \quad = \begin{cases} 0 & \text{if} \quad v \notin \{27, 28\} \lor r = 0 \lor r \ge \mathtt{secp256k1n} \lor s = 0 \lor s \ge \mathtt{secp256k1n} \\ 0 & \text{if} \quad \mathtt{EDSARECWER}(h, v - 27, r, s) = \mathcal{Q} \\ 32 & \text{otherwise} \end{cases}$$

$$\begin{array}{llll} \text{(213)} & \text{if} & \|\mathbf{o}\| = 32: \\ \text{(214)} & \mathbf{o}[0.11] & = & 0 \\ \text{(215)} & \mathbf{o}[12.31] & = & \text{KEC} \text{[ECDSARECOVE} (h, v-27, r, s)] \text{[12.31]} & \text{where:} \\ \text{(216)} & \mathbf{d}[0.\text{(} [|I\_{\text{d}}| - 1] \text{)} & = & I\_{\text{d}} \\ \text{(217)} & \mathbf{d}[\|I\_{\text{d}}\| \dots] & = & (0, 0, \dots) \\ \text{(218)} & h & = & \mathbf{d}[0.31] \\ \text{(219)} & v & = & \mathbf{d}[32.63] \\ \text{(220)} & r & = & \mathbf{d}[64\dots 95] \\ \text{(221)} & s & = & \mathbf{d}[96.127] \\ \end{array}$$

We define ΞSHA256 and ΞRIP160 as precompiled contracts implementing the SHA2-256 and RIPEMD-160 hash functions respectively. Their gas usage is dependent on the input data size, a factor rounded up to the nearest number of words.

$$\begin{array}{rcl} \text{(222)} \end{array} \quad \text{(221)} \quad \begin{array}{rcl} \Xi\_{\mathsf{g\_{K256}}} \equiv & \Xi\_{\mathsf{PRE}} \quad \text{where:} \ \mathsf{M} \ \mathsf{M} \ \mathsf{N} \ \mathsf{N} \ \mathsf{N} \end{array}$$

$$\begin{array}{rcl} \text{(223)} \end{array} \quad \text{(22)} \quad \begin{array}{rcl} g\_{\text{t}} &=& 60 + 12 \left\lceil \frac{\|I\_{\mathbf{d}}\|}{32} \right\rceil \end{array}$$

$$\begin{array}{ccccc}(224) & & \mathbf{o}[0..31] & = & \mathbf{SHA256}(I\_{\mathbf{d}})\\(225) & & & \Xi\_{\mathbf{R1P160}} \equiv & \Xi\_{\mathbf{R2E}} & \text{where:}\end{array}$$

$$\begin{array}{ccccc}\text{(226)} & & & & & \\ \end{array}$$

$$g\_{\mathbf{r}} = -600 + 120 \left\lceil \frac{||I\_{\mathbf{d}}||}{32} \right\rceil$$

$$\mathbf{(227)}\tag{227}$$

$$\begin{array}{rcl} \text{(228)} & \text{(} \mathbf{o} \text{[12.31])} & = & \mathbf{R} \mathbf{I} \mathbf{P} \mathbf{E} \mathbf{M} \mathbf{160} (I\_\mathbf{d}) \end{array}$$

For the purposes here, we assume we have well-defined standard cryptographic functions for RIPEMD-160 and SHA2-256 of the form:

$$\begin{array}{rcl} \text{(229)} & & \text{(21)} \\ \text{(22)} & & \text{(21)} \end{array}$$

$$\begin{array}{rcl} \text{(230)} & & \text{RIPEM160(i \in \mathbb{B})} & \equiv & o \in \mathbb{B}\_{20} \end{array}$$

The fourth contract, the identity function ΞID simply defines the output as the input:

$$\begin{array}{ccccc}\text{(231)}\\\end{array}\text{\(231\)}\qquad\qquad\qquad\qquad\qquad\begin{array}{ccc}\Xi\_{\mathsf{IP}} &\equiv& \Xi\_{\mathsf{PK}} & \text{where:}\end{array}$$

(232) 
$$g\_{\rm r} = -15 + 3\left\lceil \frac{\left\| I\_{\rm d} \right\|}{32} \right\rceil$$

$$\begin{array}{ccccc}\text{(233)} & & & & \mathbf{o} & = & I\_{\mathbf{d}} \\ \end{array}$$

The fifth contract performs arbitrary-precision exponentiation under modulo. Here, 0<sup>0</sup> is taken to be one, and x mod 0 is zero for all x. The first word in the input specifies the number of bytes that the first non-negative integer B occupies. The second word in the input specifies the number of bytes that the second non-negative integer E occupies. The third word in the input specifies the number of bytes that the third non-negative integer M occupies. These three words are followed by B, E and M. The rest of the input is discarded. Whenever the input is too short, the missing bytes are considered to be zero. The output is encoded big-endian into the same format as M's.

(234) ΞEXPMOD ≡ ΞPRE except: <sup>g</sup><sup>r</sup> = max 200, \$ f max(`M, `B) max(` 0 <sup>E</sup>, 1) <sup>G</sup>quaddivisor %! (235) (236) Gquaddivisor ≡ 3 f(x) ≡ l x 8 m2 (237) ` 0 <sup>E</sup> = 0 if `<sup>E</sup> ≤ 32 ∧ E = 0 blog<sup>2</sup> (E)c if `<sup>E</sup> ≤ 32 ∧ E 6= 0 8(`<sup>E</sup> − 32) + blog<sup>2</sup> (i[(96 + `B)..(127 + `B)])c if 32 < `<sup>E</sup> ∧ i[(96 + `B)..(127 + `B)] 6= 0 8(`<sup>E</sup> − 32) otherwise (238) o = B <sup>E</sup> mod M (239) ∈ N8`<sup>M</sup> (240) `<sup>B</sup> ≡ i[0..31] (241) `<sup>E</sup> ≡ i[32..63] (242) `<sup>M</sup> ≡ i[64..95] (243) B ≡ i[96..(95 + `B)] (244) E ≡ i[(96 + `B)..(95 + `<sup>B</sup> + `E)] (245) M ≡ i[(96 + `<sup>B</sup> + `E)..(95 + `<sup>B</sup> + `<sup>E</sup> + `M)] i[x] ≡ ( Id[x] if x < kIdk 0 otherwise (246)

E.1. zkSNARK Related Precompiled Contracts. We choose two numbers, both of which are prime.

(247) p ≡ 21888242871839275222246405745257275088696311157297823662689037894645226208583

$$(248)\qquad q \equiv \ 21888242871839275222246405745257275088548364409416034343698204186575808495617$$

Since p is a prime number, {0, 1, . . . , p − 1} forms a field with addition and multiplication modulo p. We call this field Fp.

We define a set C<sup>1</sup> with

$$(249) \newline \qquad \qquad C\_1 \equiv \{(X, Y) \in F\_\mathcal{P} \times F\_\mathcal{P} \mid Y^2 = X^3 + 3\} \cup \{(0, 0)\}$$

We define a binary operation + on C<sup>1</sup> for distinct elements (X1, Y1),(X2, Y2) with

<span id="page-23-0"></span>
$$\begin{aligned} \text{(250)} \qquad &(X\_1, Y\_1) + (X\_2, Y\_2) \quad \equiv \quad \begin{cases} (X, Y) & \text{if } X\_1 \neq X\_2 \\ (0, 0) & \text{otherwise} \end{cases} \\ \lambda &\equiv \quad \frac{Y\_2 - Y\_1}{X\_2 - X\_1} \\ \quad &X \equiv \quad \lambda^2 - X\_1 - X\_2 \\ \quad &Y \equiv \quad \lambda (X\_1 - X) - Y\_1 \end{aligned}$$

<span id="page-23-1"></span>In the case where (X1, Y1) = (X2, Y2), we define + on C<sup>1</sup> with

$$\begin{aligned} \text{(251)}\\ \quad \begin{aligned} (X\_1, Y\_1) + (X\_2, Y\_2) & \equiv & \begin{cases} (X, Y) & \text{if } Y\_1 \neq 0\\ (0, 0) & \text{otherwise} \end{cases} \\ \quad \lambda & \equiv & \frac{3X\_1^2}{2Y\_1} \\ \quad X & \equiv & \lambda^2 - 2X\_1 \\ Y & \equiv & \lambda(X\_1 - X) - Y\_1 \end{aligned} \end{aligned}$$

<span id="page-23-2"></span>(C1, +) is known to form a group. We define scalar multiplication · with

$$\begin{array}{c} \text{(252)} \end{array} \tag{252}$$

for a natural number n and a point P in C1.

We define P<sup>1</sup> to be a point (1, 2) on C1. Let G<sup>1</sup> be the subgroup of (C1, +) generated by P1. G<sup>1</sup> is known to be a cyclic group of order q. For a point P in G1, we define log<sup>P</sup><sup>1</sup> (P) to be the smallest natural number n satisfying n · P<sup>1</sup> = P. log<sup>P</sup><sup>1</sup> (P) is at most q − 1.

Let Fp<sup>2</sup> be a field Fp[i]/(i <sup>2</sup> + 1). We define a set C<sup>2</sup> with

$$(253) \qquad \qquad C\_2 \equiv \{(X, Y) \in F\_{p^2} \times F\_{p^2} \mid Y^2 = X^3 + 3(i + 9)^{-1}\} \cup \{(0, 0)\}$$

We define a binary operation + and scalar multiplication · with the same equations [\(250\)](#page-23-0), [\(251\)](#page-23-1) and [\(252\)](#page-23-2). (C2, +) is also known to be a group. We define P<sup>2</sup> in C<sup>2</sup> with

# (254) P<sup>2</sup> ≡ (11559732032986387107991004021392285783925812861821192530917403151452391805634 × i +10857046999023057135944570762232829481370756359578518086990519993285655852781, 4082367875863433681332203403145435568316851327593401208105741076214120093531 × i +8495653923123431417604973247489272438418190587263600148770280649306958101930)

We define G<sup>2</sup> to be the subgroup of (C2, +) generated by P2. G<sup>2</sup> is known to be the only cyclic group of order q on C2. For a point P in G2, we define log<sup>P</sup><sup>2</sup> (P) be the smallest natural number n satisfying n · P<sup>2</sup> = P. With this definition, log<sup>P</sup><sup>2</sup> (P) is at most q − 1.

Let G<sup>T</sup> be the multiplicative abelian group underlying F<sup>q</sup> <sup>12</sup> . It is known that a non-degenerate bilinear map e : G<sup>1</sup> × G<sup>2</sup> → G<sup>T</sup> exists. This bilinear map is a type three pairing. There are several such bilinear maps, it does not matter which is chosen to be e. Let P<sup>T</sup> = e(P1, P2), a be a set of k points in G1, and b be a set of k points in G2. It follows from the definition of a pairing that the following are equivalent

<span id="page-23-3"></span>
$$\begin{array}{ccccccccc}\text{(255)} & & \log\_{P\_1}(a\_1) \times \log\_{P\_2}(b\_1) + \dots + \log\_{P\_1}(a\_k) \times \log\_{P\_2}(b\_k) & \equiv & 1 \mod q \end{array}$$

$$\begin{array}{ccccc}\hline\end{array}\tag{256}$$

Thus the pairing operation provides a method to verify [\(255\)](#page-23-3).

A 32 byte number x ∈ P<sup>256</sup> might and might not represent an element of Fp.

$$\text{(257)}\tag{257}$$

$$\delta\_{\mathbf{p}}(\mathbf{x}) \equiv \begin{cases} \mathbf{x} & \text{if } \mathbf{x} < p \\ \mathcal{B} & \text{otherwise} \end{cases}$$

A 64 byte data x ∈ B<sup>512</sup> might and might not represent an element of G1.

$$\begin{array}{rcl} \text{(258)}\\ \text{(258)} \end{array} \qquad \qquad \begin{array}{rcl} \delta\_1(\mathbf{x}) & \equiv & \begin{cases} g\_1 & \text{if } g\_1 \in G\_1 \\ \mathcal{Q} & \text{otherwise} \end{cases} \end{array}$$

$$\begin{array}{rcl} \text{(259)} \end{array} \qquad \begin{array}{rcl} g\_1 & \equiv & \begin{cases} (x,y) & \text{if } x \neq \varpi \land y \neq \varpi \\ \mathcal{D} & \text{otherwise} \end{cases} \end{array}$$

$$\begin{array}{ccccc}\text{(260)} & & & & x & \equiv & \delta\_{\mathbb{P}}(\mathbf{x}[0..31])\end{array}$$

$$\begin{array}{rcl} \text{(261)}\\ \text{ (261)} \end{array} \qquad \qquad \qquad y \quad \equiv \quad \delta\_{\mathbb{P}} (\mathbf{x}[32...63]) \text{ }$$

A 128 byte data x ∈ B<sup>1024</sup> might and might not represent an element of G2.

$$\begin{array}{rcl} \text{(262)} & & \delta\_2(\mathbf{x}) & \equiv & \begin{cases} g\_2 & \text{if } g\_2 \in G\_2 \\ \mathcal{B} & \text{otherwise} \end{cases} \end{array}$$

$$\begin{array}{rclcrcl} \text{(263)} & g\_2 & \equiv & \begin{cases} ((x\_0i + y\_0), (x\_1i + y\_1)) & \text{if } x\_0 \neq \mathcal{D} \land y\_0 \neq \mathcal{D} \land x\_1 \neq \mathcal{D} \land y\_1 \neq \mathcal{D})\\ \mathcal{D} & \text{otherwise} \end{cases} \\\\ \text{(264)} & x\_0 & \equiv & \delta\_{\mathbb{P}}(\mathbf{x}[0..31])\\ \text{(265)} & \dots & \dots & \dots & \delta\_{\mathbb{P}}(\mathbf{x}[32.42]) \end{array}$$

$$\begin{array}{rcl}(265) & & y\_0 & \equiv & \delta\_{\mathbf{p}} (\mathbf{x}[32..63])\end{array}$$

(266) x<sup>1</sup> ≡ δp(x[64..95])

$$\begin{array}{rcl} \text{(267)} \end{array} \qquad \qquad y\_1 \quad \equiv \quad \delta\_\mathbb{P}(\mathbf{x}[96...127]);$$

We define ΞSNARKV as a precompiled contract which checks if [\(255\)](#page-23-3) holds, for intended use in zkSNARK verification.

| (268)                    | ΞSNARKV | ≡ | ΞPRE<br>except:                                                                                                                                                          |
|--------------------------|---------|---|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| (269)ΞSNARKV(σ, g, A, I) |         | = | (∅,<br>0, A,())<br>if F                                                                                                                                                  |
| (270)                    | F       | ≡ | (kIdk mod 192 6= 0 ∨ (∃j. aj = ∅<br>∨ bj = ∅))                                                                                                                           |
| (271)                    | k       | = | kIdk<br>192                                                                                                                                                              |
| (272)                    | gr      | = | 34000k + 45000                                                                                                                                                           |
| (273)                    | o[031]  | ≡ | (<br>if v ∧ ¬F<br>0x0000000000000000000000000000000000000000000000000000000000000001<br>if ¬v ∧ ¬F<br>0x0000000000000000000000000000000000000000000000000000000000000000 |
| (274)                    | v       | ≡ | (logP1<br>(a1) × logP2<br>(b1) + · · · + logP1<br>(ak) × logP2<br>(bk) ≡ 1<br>mod q)                                                                                     |
| (275)                    | a1      | ≡ | δ1(Id[063])                                                                                                                                                              |
| (276)                    | b1      | ≡ | δ2(Id[64191])                                                                                                                                                            |
|                          |         |   |                                                                                                                                                                          |
| (277)                    | ak      | ≡ | δ1(Id[(kIdk − 192)(kIdk − 129)])                                                                                                                                         |
| (278)                    | bk      | ≡ | δ2(Id[(kIdk − 128)(kIdk − 1)])                                                                                                                                           |

<span id="page-24-0"></span>We define a precompiled contract for addition on G1.

$$\begin{array}{rclcrcl} \text{(279)} & & \Xi\_{\mathsf{u}\mathsf{u},\mathsf{p}\mathsf{u}} & \equiv & \Xi\_{\mathsf{u}\mathsf{u},\mathsf{p}\mathsf{u}} & \text{except:}\\ \text{(280)} & & & \Xi\_{\mathsf{u}\mathsf{u},\mathsf{u}\mathsf{u}}(\sigma,g,A,I) & = & (\mathcal{Z},0,A,\langle\rangle) & \text{if } x=\mathcal{Z}\vee y=\mathcal{Z}\\ \text{(281)} & & & g\_{\mathsf{r}} & = & 150\\ \text{(282)} & & & \mathbf{o} & \equiv & \delta\_{1}^{-1}(x+y) & \text{where } + \text{ is the group operation in }G\_{1}\\ \text{(283)} & & & x & \equiv & \delta\_{1}\left(\bar{I}\_{\mathsf{d}}[0.63]\right) \\ \text{(284)} & & & y & \equiv & \delta\_{1}\left(\bar{I}\_{\mathsf{d}}[64.127]\right) \\\\ \text{(285)} & & & & \bar{I}\_{\mathsf{d}}[x] & \equiv & \left\{ \begin{array}{l} I\_{\mathsf{d}}[x] & \text{if } x < ||I\_{\mathsf{d}}|| \\ 0 & \text{otherwise} \end{array} \right. \end{array} \end{array}$$

We define a precompiled contract for scalar multiplication on G1, where I¯<sup>d</sup> is defined in [\(285\)](#page-24-0).

$$\begin{array}{ccccc}(286) & & \Xi\_{\mathsf{BL.3NL}} \equiv & \Xi\_{\mathsf{BL}} \quad \text{except:}\\(287) & & \Xi\_{\mathsf{BL.3NL}}(\sigma, g, A, I) & = & (\mathcal{Q}, 0, A, (\cdot)) & \text{if } x = \mathcal{D} \\(288) & & g\_{\mathsf{r}} & = & 6000\\(289) & & \mathbf{o} & \equiv & \delta\_{1}^{-1}(n \cdot x) & \text{where } \cdot \text{ is the scalar multiplication in } G\_{1} \\(290) & & x & \equiv & \delta\_{1} \left(\bar{I}\_{\mathsf{L}}[0.63]\right) \\(291) & & & n & \equiv & \bar{I}\_{\mathsf{L}}[64.95] \\\end{array}$$

E.2. BLAKE2 Precompiled Contract. EIP-152 by [Hess et al. \[2016\]](#page-17-14) defines ΞBLAKE2 <sup>F</sup> as a precompiled contract implementing the compression function F used in the BLAKE2 cryptographic hashing algorithm. The F compression function is specified in RFC 7693 by [Saarinen and Aumasson \[2015\]](#page-18-10).

| (292) | ΞBLAKE2 F                | ≡ | ΞPRE<br>except:                                     |
|-------|--------------------------|---|-----------------------------------------------------|
| (293) | ΞBLAKE2 F(σ, g, A, I)    | = | (∅,<br>0, A,())<br>if kIdk 6= 213 ∨ f /∈ {0, 1}     |
| (294) | gr                       | = | r                                                   |
| (295) | o                        | ≡ | 0<br>0<br>LE8(h<br>0) ·  · LE8(h<br>7)              |
| (296) | 0<br>0, , h0<br>(h<br>7) | ≡ | F(h, m, tlow, thigh, f)<br>with r rounds and w = 64 |
| (297) | BE4(r)                   | ≡ | Id[04]                                              |
| (298) | LE8(h0)                  | ≡ | Id[412]                                             |
| (299) |                          | . |                                                     |
| (300) | LE8(h7)                  | ≡ | Id[6068]                                            |
| (301) | LE8(m0)                  | ≡ | Id[6876]                                            |
| (302) |                          | . |                                                     |
| (303) | LE8(m15)                 | ≡ | Id[188196]                                          |
| (304) | LE8(tlow)                | ≡ | Id[196204]                                          |
| (305) | LE8(thigh)               | ≡ | Id[204212]                                          |
| (306) | f                        | ≡ | Id[212]                                             |
|       |                          |   |                                                     |

where r ∈ B32, ∀i ∈ 0..7 : h<sup>i</sup> ∈ B64, ∀i ∈ 0..15 : m<sup>i</sup> ∈ B64, tlow ∈ B64, thigh ∈ B64, f ∈ B8, BE<sup>k</sup> is the k-byte big-endian representation—compare with[\(195\)](#page-19-4):

$$\text{(307)}\tag{307}$$

$$\text{(307)}\tag{308}\tag{308}\tag{309}\tag{309}\equiv (b\_0, b\_1, \dots, b\_{k-1}): x = \sum\_{n=0}^{k-1} b\_n \cdot 256^{k-1-n}$$

and LE<sup>k</sup> is the k-byte little-endian representation:

$$\begin{array}{cc} \text{(308)} & \text{LE}\_k(x) \equiv (b\_0, b\_1, \dots, b\_{k-1}) : x = \sum\_{n=0}^{k-1} b\_n \cdot 256^n \\ \end{array}$$

### <span id="page-25-1"></span>Appendix F. Signing Transactions

<span id="page-25-0"></span>Transactions are signed using recoverable ECDSA signatures. This method utilises the SECP-256k1 curve as described by [Courtois et al. \[2014\]](#page-17-15), and is implemented similarly to as described by [Gura et al. \[2004\]](#page-17-16) on p. 9 of 15, para. 3.

It is assumed that the sender has a valid private key pr, which is a randomly selected positive integer (represented as a byte array of length 32 in big-endian form) in the range [1, secp256k1n − 1].

We assume the existence of functions ECDSAPUBKEY, ECDSASIGN and ECDSARECOVER. These are formally defined in the literature, e.g. by [Johnson et al. \[2001\]](#page-17-17).

$$(\text{309}) \qquad \qquad \qquad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad p\_{\text{u}} \in \mathbb{B}\_{64}$$

(310) ECDSASIGN(e ∈ B32, p<sup>r</sup> ∈ B32) ≡ (v ∈ B1, r ∈ B32, s ∈ B32)

$$(311) \qquad \qquad \mathsf{ECDASECONER}(e \in \mathbb{B}\_{32}, v \in \mathbb{B}\_1, r \in \mathbb{B}\_{32}, s \in \mathbb{B}\_{32}) \quad \equiv \quad p\_u \in \mathbb{B}\_{64} \tag{113}$$

Where p<sup>u</sup> is the public key, assumed to be a byte array of size 64 (formed from the concatenation of two positive integers each < 2 <sup>256</sup>), p<sup>r</sup> is the private key, a byte array of size 32 (or a single positive integer in the aforementioned range) and e is the hash of the transaction, h([T](#page-26-0)). It is assumed that v is the 'recovery identifier'. The recovery identifier is a 1 byte value specifying the parity and finiteness of the coordinates of the curve point for which r is the x-value; this value is in the range of [0, 3], however we declare the upper two possibilities, representing infinite values, invalid. The value 0 represents an even y value and 1 represents an odd y value.

<span id="page-25-3"></span><span id="page-25-2"></span>We declare that an ECDSA signature is invalid unless all the following conditions are true:

- (312) 0 < r < secp256k1n
- (313) 0 < s < secp256k1n ÷ 2 + 1
- (314) [v](#page-25-1) ∈ {0, 1}

where:

(315) secp256k1n = 115792089237316195423570985008687907852837564279074904382605163141518161494337

Note that this restriction on s is more stringent than restriction [212](#page-21-1) in the ΞECREC precompile; see EIP-2 by [Buterin \[2015\]](#page-17-18) for more detail.

For a given private key, pr, the Ethereum address A(pr) (a 160-bit value) to which it corresponds is defined as the rightmost 160-bits of the Keccak-256 hash of the corresponding ECDSA public key:

$$(\text{316})\tag{316}$$

$$(\text{316})\tag{317}$$

<span id="page-26-0"></span>The message hash, h(T), to be signed is the Keccak-256 hash of the transaction. Four different flavours of signing schemes are available:

$$(317) \qquad \qquad L\_{\mathbf{X}}(T) \quad \equiv \begin{cases} (T\_{\mathbf{n}}, T\_{\mathbf{p}}, T\_{\mathbf{g}}, T\_{\mathbf{t}}, T\_{\mathbf{v}}, \mathbf{p}) & \text{if } T\_{\mathbf{x}} = 0 \land T\_{\mathbf{w}} \in \{27, 28\} \\ (T\_{\mathbf{n}}, T\_{\mathbf{p}}, T\_{\mathbf{g}}, T\_{\mathbf{t}}, T\_{\mathbf{v}}, \mathbf{p}, \beta, (\cdot), (\cdot)) & \text{if } T\_{\mathbf{x}} = 0 \land T\_{\mathbf{w}} \in \{2\beta + 35, 2\beta + 36\} \\ (T\_{\mathbf{c}}, T\_{\mathbf{n}}, T\_{\mathbf{p}}, T\_{\mathbf{g}}, T\_{\mathbf{t}}, T\_{\mathbf{v}}, \mathbf{p}, T\_{\mathbf{A}}) & \text{if } T\_{\mathbf{x}} = 1 \\ (T\_{\mathbf{c}}, T\_{\mathbf{n}}, T\_{\mathbf{t}}, T\_{\mathbf{m}}, T\_{\mathbf{g}}, T\_{\mathbf{t}}, T\_{\mathbf{v}}, \mathbf{p}, T\_{\mathbf{A}}) & \text{if } T\_{\mathbf{x}} = 2 \end{cases}$$

$$\begin{array}{rcl} \text{where} &\\ \mathbf{p} & \equiv & \begin{cases} T\_{\mathbf{l}} & \text{if } T\_{\mathbf{t}} = \mathcal{Q} \\ T\_{\mathbf{d}} & \text{otherwise} \end{cases} \\\\ (318) & \equiv & \begin{cases} \text{KEC}(\text{RLP}(L\_{\text{X}}(T))) & \text{if } T\_{\mathbf{x}} = 0 \\ \text{KEC}(T\_{\mathbf{x}} \cdot \text{RLP}(L\_{\text{X}}(T))) & \text{otherwise} \end{cases} \end{array}$$

The signed transaction G(T, pr) is defined as:

$$\begin{aligned} \text{(319)}\\ \text{(320)} \end{aligned} \qquad \begin{aligned} G(T, p\_{\text{\tiny t}}) & \equiv T \quad \text{except:}\\ \begin{pmatrix} T\_{\text{\tiny t}}, T\_{\text{\tiny t}} \end{pmatrix} = \mathbf{E} \mathbf{C} \mathbf{S} \mathbf{A} \mathbf{S} \mathbf{I} \mathbf{G} \mathbf{M} (h(T), p\_{\text{\tiny t}}) \end{aligned}$$

[Reiterating from previously:](#page-4-7)

(321) T<sup>r</sup> = [r](#page-25-2) (322) T<sup>s</sup> = [s](#page-25-3)

and [T](#page-4-8)<sup>w</sup> of legacy transactions is either 27 + T<sup>y</sup> or 2[β](#page-2-1) + 35 + Ty.

We may then define the sender function S of the transaction as:

$$\begin{array}{rcl} \text{(323)} & \quad & S(T) & \equiv & \mathcal{B}\_{96\dots255} \Big\{ \text{KEC} \Big\{ \text{EC} \text{CD} \text{SEREC} \text{WER} \left( h(T), v, T\_{\text{r}}, T\_{\text{s}} \right) \Big\} \Big\} \end{array}$$

$$\begin{array}{rcl} \text{(324)}\\ \text{(324)}\\ \text{(324)} \end{array} \qquad \begin{cases} T\_{\text{w}} - 27 & \text{if } T\_{\text{x}} = 0 \land T\_{\text{w}} \in \{27, 28\} \\ (T\_{\text{w}} - 35) \text{ mod } 2 & \text{if } T\_{\text{x}} = 0 \land T\_{\text{w}} \in \{2\beta + 35, 2\beta + 36\} \\ T\_{\text{y}} & \text{if } T\_{\text{x}} = 1 \lor T\_{\text{x}} = 2 \end{array}$$

The assertion that the sender of a signed transaction equals the address of the signer should be self-evident:

$$(325) \tag{325} \tag{32.5} \tag{32.6} \tag{32.6}$$

### Appendix G. Fee Schedule

<span id="page-27-0"></span>The fee schedule G is a tuple of scalar values corresponding to the relative costs, in gas, of a number of abstract operations that a transaction may effect.

<span id="page-27-9"></span><span id="page-27-7"></span><span id="page-27-6"></span><span id="page-27-5"></span>

| Name               | Value | Description                                                                                   |
|--------------------|-------|-----------------------------------------------------------------------------------------------|
| Gzero              | 0     | Nothing paid for operations of the set Wzero.                                                 |
| Gjumpdest          | 1     | Amount of gas to pay for a JUMPDEST operation.                                                |
| Gbase              | 2     | Amount of gas to pay for operations of the set Wbase.                                         |
| Gverylow           | 3     | Amount of gas to pay for operations of the set Wverylow.                                      |
| Glow               | 5     | Amount of gas to pay for operations of the set Wlow.                                          |
| Gmid               | 8     | Amount of gas to pay for operations of the set Wmid.                                          |
| Ghigh              | 10    | Amount of gas to pay for operations of the set Whigh.                                         |
| Gwarmaccess        | 100   | Cost of a warm account or storage access.                                                     |
| Gaccesslistaddress | 2400  | Cost of warming up an account with the access list.                                           |
| Gaccessliststorage | 1900  | Cost of warming up a storage with the access list.                                            |
| Gcoldaccountaccess | 2600  | Cost of a cold account access.                                                                |
| Gcoldsload         | 2100  | Cost of a cold storage access.                                                                |
| Gsset              | 20000 | Paid for an SSTORE operation when the storage value is set to non-zero from zero.             |
| Gsreset            | 2900  | Paid for an SSTORE operation when the storage value's zeroness remains unchanged or           |
|                    |       | is set to zero.                                                                               |
| Rsclear            | 4800  | Refund given (added into refund counter) when the storage value is set to zero from           |
|                    |       | non-zero. The refund amount is defined as Gsreset + Gaccessliststorage.                       |
| Gselfdestruct      | 5000  | Amount of gas to pay for a SELFDESTRUCT operation.                                            |
| Gcreate            | 32000 | Paid for a CREATE operation.                                                                  |
| Gcodedeposit       | 200   | Paid per byte for a CREATE operation to succeed in placing code into state.                   |
| Ginitcodeword      | 2     | Paid per word of the initcode at the beginning of a deploy transaction, a CREATE,             |
|                    |       | or a CREATE2 operation.                                                                       |
| Gcallvalue         | 9000  | Paid for a non-zero value transfer as part of the CALL operation.                             |
| Gcallstipend       | 2300  | A stipend for the called contract subtracted from Gcallvalue for a non-zero value transfer.   |
| Gnewaccount        | 25000 | Paid for a CALL or SELFDESTRUCT operation which creates an account.                           |
| Gexp               | 10    | Partial payment for an EXP operation.                                                         |
| Gexpbyte           | 50    | Partial payment when multiplied by the number of bytes in the exponent for the EXP operation. |
| Gmemory            | 3     | Paid for every additional word when expanding memory.                                         |
| Gtxcreate          | 32000 | Paid by all contract-creating transactions after the Homestead transition.                    |
| Gtxdatazero        | 4     | Paid for every zero byte of data or code for a transaction.                                   |
| Gtxdatanonzero     | 16    | Paid for every non-zero byte of data or code for a transaction.                               |
| Gtransaction       | 21000 | Paid for every transaction.                                                                   |
| Glog               | 375   | Partial payment for a LOG operation.                                                          |
| Glogdata           | 8     | Paid for each byte in a LOG operation's data.                                                 |
| Glogtopic          | 375   | Paid for each topic of a LOG operation.                                                       |
| Gkeccak256         | 30    | Paid for each KECCAK256 operation.                                                            |
| Gkeccak256word     | 6     | Paid for each word (rounded up) for input data to a KECCAK256 operation.                      |
| Gcopy              | 3     | Partial payment for *COPY operations, multiplied by words copied, rounded up.                 |
| Gblockhash         | 20    | Payment for each BLOCKHASH operation.                                                         |

Appendix H. Virtual Machine Specification

<span id="page-27-8"></span><span id="page-27-4"></span><span id="page-27-3"></span><span id="page-27-2"></span><span id="page-27-1"></span>When interpreting 256-bit binary values as integers, the representation is big-endian.

When a 256-bit machine datum is converted to and from a 160-bit address or hash, the rightwards (low-order for BE) 20 bytes are used and the leftmost 12 are discarded or filled with zeroes, thus the integer values (when the bytes are interpreted as big-endian) are equivalent.

#### H.1. Gas Cost. The general gas cost function, C, is defined as:

$$(326)$$

$$C(\sigma,\mu,A,\nu) \coloneqq \begin{cases} C\_{\text{CNOT}}(\sigma,\mu,A,I) & \text{if } \text{w = \text{STOTSE}(\sigma)} \\ G\_{\text{Csup}} & \text{if } w = \text{EXO} \times \mu\_{1}[1] \\ G\_{\text{Csup}} + G\_{\text{Csubs}} \times (1 + \|\text{deg}\_{\text{m}}(\mu\_{1}[1])\|) & \text{if } w = \text{EXO} \times \mu\_{1}[1] \\ G\_{\text{Csup}} + G\_{\text{Csubs}} \times (\mu\_{1}[2] + 3) & \text{if } w = \text{EXO} \times \mu\_{1}[1] \\ G\_{\text{Csubs}}(\mu\_{1}[0] \text{ mod } 2^{0.4}) + G\_{\text{Crow}} \times [\mu\_{3}[3] + 3] & \text{if } w = \text{EXO} \times \text{ECO} \times \text{ECO} \\ G\_{\text{Cmax}}(\mu\_{1}[0] \text{ mod } 2^{0.4}) & \text{if } w = \text{EXO} \times \mu\_{1}[2] \\ G\_{\text{Cfrac}} + G\_{\text{Csubs}} \times \mu\_{1}[1] & \text{if } w = \text{LOO} \times \mu\_{1}[2] \\ G\_{\text{Cfrac}} + G\_{\text{Csubs}} \times \mu\_{1}[1] + G\_{\text{Cups}} & \text{if } w = \text{LOO} \\ G\_{\text{Cfrac}} + G\_{\text{Csubs}} \times \mu\_{1}[2] + G\_{\text{Csubs}} & \text{if } w = \text{LOO} \\ G\_{\text{Ctext}} + G\_{\text{Csubs}} \times \mu\_{1}[1] + G\_{\text{Cups}} & \text{if } w = \text{LOO} \\ G\_{\text{Ctext}} + G\_{\text{$$

$$\text{(327)}\tag{327} = \text{(b}\text{l}\text{l}\text{m}\_{\text{pc}}\text{)}\quad\text{if}\quad\mu\_{\text{pc}}<\|I\_{\text{b}}\|\text{l}$$

<span id="page-28-0"></span>where:

$$(328) \qquad \qquad \qquad C\_{\text{mem}}(a) \equiv G\_{\text{memory}} \cdot a + \left\lfloor \frac{a^2}{512} \right\rfloor$$

$$(329) \qquad \qquad \qquad C\_{\text{aacossa}}(x, A) \equiv \begin{cases} G\_{\text{warmacossa}} & \text{if } \quad x \in A\_{\mathbf{a}} \\ G\_{\text{coldaccoutacossa}} & \text{otherwise} \end{cases}$$

with CCALL, CSELFDESTRUCT, CSLOAD and CSSTORE as specified in the appropriate section below. We define the following subsets of instructions:

Wzero = {STOP, RETURN, REVERT}

Wbase = {ADDRESS, ORIGIN, CALLER, CALLVALUE, CALLDATASIZE, CODESIZE, GASPRICE, COINBASE,

TIMESTAMP, NUMBER, PREVRANDAO, GASLIMIT, CHAINID, RETURNDATASIZE, POP, PC, MSIZE, GAS, BASEFEE, PUSH0}

Wverylow = {ADD, SUB, NOT, LT, GT, SLT, SGT, EQ, ISZERO, AND, OR, XOR, BYTE, SHL, SHR, SAR,

CALLDATALOAD, MLOAD, MSTORE, MSTORE8, PUSH1, ..., PUSH32, DUP\*, SWAP\*}

- Wlow = {MUL, DIV, SDIV, MOD, SMOD, SIGNEXTEND, SELFBALANCE}
- Wmid = {ADDMOD, MULMOD, JUMP}

Whigh = {JUMPI}

Wcopy = {CALLDATACOPY, CODECOPY, RETURNDATACOPY}

Wcall = {CALL, CALLCODE, DELEGATECALL, STATICCALL}

Wextaccount = {BALANCE, EXTCODESIZE, EXTCODEHASH}

Note the memory cost component, given as the product of Gmemory and the maximum of 0 & the ceiling of the number of words in size that the memory must be over the current number of words, µ<sup>i</sup> in order that all accesses reference valid memory whether for read or write. Such accesses must be for non-zero number of bytes.

Referencing a zero length range (e.g. by attempting to pass it as the input range to a CALL) does not require memory to be extended to the beginning of the range. µ 0 i is defined as this new maximum number of words of active memory; special cases are given where these two are not equal.

Note also that Cmem is the memory cost function (the expansion function being the difference between the cost before and after). It is a polynomial, with the higher-order coefficient divided and floored, and thus linear up to 704B of memory used, after which it costs substantially more.

While defining the instruction set, we defined the memory-expansion for range function, M, thus:

$$\begin{array}{c} \text{(330)} \end{array} \qquad \begin{array}{c} M(s, f, l) \equiv \begin{cases} s & \text{if } \quad l = 0\\ \max(s, \lceil (f + l) \div 32 \rceil) & \text{otherwise} \end{cases} \end{array}$$

Another useful function is "all but one 64th" function L defined as:

<span id="page-29-1"></span>
$$(331)\tag{331}$$

$$L(n) \equiv n - \lfloor n/64 \rfloor$$

<span id="page-29-0"></span>H.2. Instruction Set. As previously specified in section [9,](#page-12-2) these definitions take place in the final context there. In particular we assume O is the EVM state-progression function and define the terms pertaining to the next cycle's state (σ 0 , µ 0 ) such that:

$$(332) \qquad \qquad O(\sigma, \mu, A, I) \equiv (\sigma', \mu', A', I) \quad \text{with exceptions, as noted}$$

Here given are the various exceptions to the state transition rules given in section [9](#page-12-2) specified for each instruction, together with the additional instruction-specific definitions of J and C. For each instruction, also specified is α, the additional items placed on the stack and δ, the items removed from stack, as defined in section [9.](#page-12-2)

<span id="page-30-0"></span>

| All arithmetic is modulo 2256 unless otherwise noted. The zero-th power of zero 00<br>is defined to be one. |                                                                                                                                                                                                                                                                                  |   |   |                                                                                                                                                                                                                                                                                                                                                                                               |
|-------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---|---|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Value                                                                                                       | Mnemonic                                                                                                                                                                                                                                                                         | δ | α | Description                                                                                                                                                                                                                                                                                                                                                                                   |
| 0x00                                                                                                        | STOP                                                                                                                                                                                                                                                                             | 0 | 0 | Halts execution.                                                                                                                                                                                                                                                                                                                                                                              |
| 0x01                                                                                                        | ADD                                                                                                                                                                                                                                                                              | 2 | 1 | Addition operation.<br>0<br>[0] ≡ µs<br>µ<br>[0] + µs<br>[1]<br>s                                                                                                                                                                                                                                                                                                                             |
| 0x02                                                                                                        | MUL                                                                                                                                                                                                                                                                              | 2 | 1 | Multiplication operation.<br>0<br>µ<br>[0] ≡ µs<br>[0] × µs<br>[1]<br>s                                                                                                                                                                                                                                                                                                                       |
| 0x03                                                                                                        | SUB                                                                                                                                                                                                                                                                              | 2 | 1 | Subtraction operation.<br>0<br>µ<br>[0] ≡ µs<br>[0] − µs<br>[1]<br>s                                                                                                                                                                                                                                                                                                                          |
| 0x04                                                                                                        | DIV                                                                                                                                                                                                                                                                              | 2 | 1 | Integer division operation.<br>(<br>0<br>if<br>µs<br>[1] = 0<br>0<br>µ<br>[0] ≡<br>s<br>bµs<br>[0] ÷ µs<br>[1]c<br>otherwise                                                                                                                                                                                                                                                                  |
| 0x05                                                                                                        | SDIV                                                                                                                                                                                                                                                                             | 2 | 1 | Signed integer division operation (truncated).<br><br>0<br>if<br>µs<br>[1] = 0<br><br>0<br>255<br>255 ∧<br>[0] ≡<br>µ<br>−2<br>[0] = −2<br>[1] = −1<br>if<br>µs<br>µs<br>s<br><br>[0] ÷ µs<br>[1])b µs<br>[0] ÷ µs<br>[1] c<br>sgn(µs<br>otherwise<br>Where all values are treated as two's complement signed 256-bit integers.<br>255 is negated.<br>Note the overflow semantic when −2 |
| 0x06                                                                                                        | MOD                                                                                                                                                                                                                                                                              | 2 | 1 | Modulo remainder operation.<br>(<br>0<br>if<br>µs<br>[1] = 0<br>0<br>µ<br>[0] ≡<br>s<br>µs<br>[0] mod µs<br>[1]<br>otherwise                                                                                                                                                                                                                                                                  |
| 0x07                                                                                                        | SMOD                                                                                                                                                                                                                                                                             | 2 | 1 | Signed modulo remainder operation.<br>(<br>0<br>if<br>µs<br>[1] = 0<br>0<br>[0] ≡<br>µ<br>s<br>[0])( µs<br>[0]  mod  µs<br>[1] )<br>sgn(µs<br>otherwise<br>Where all values are treated as two's complement signed 256-bit integers.                                                                                                                                                          |
| 0x08                                                                                                        | ADDMOD                                                                                                                                                                                                                                                                           | 3 | 1 | Modulo addition operation.<br>(<br>0<br>if<br>µs<br>[2] = 0<br>0<br>[0] ≡<br>µ<br>s<br>(µs<br>[0] + µs<br>[1]) mod µs<br>[2]<br>otherwise<br>All intermediate calculations of this operation are not subject to the 2256<br>modulo.                                                                                                                                                           |
| 0x09                                                                                                        | MULMOD                                                                                                                                                                                                                                                                           | 3 | 1 | Modulo multiplication operation.<br>(<br>0<br>if<br>µs<br>[2] = 0<br>0<br>[0] ≡<br>µ<br>s<br>[0] × µs<br>(µs<br>[1]) mod µs<br>[2]<br>otherwise<br>All intermediate calculations of this operation are not subject to the 2256<br>modulo.                                                                                                                                                     |
| 0x0a                                                                                                        | EXP                                                                                                                                                                                                                                                                              | 2 | 1 | Exponential operation.<br>0<br>[0]µs<br>[1]<br>µ<br>[0] ≡ µs<br>s                                                                                                                                                                                                                                                                                                                             |
| 0x0b<br>µs                                                                                                  | 2<br>1<br>Extend length of two's complement signed integer.<br>SIGNEXTEND<br>(<br>i 6<br>µs<br>[1]t<br>if<br>t<br>where t = 256 − 8(µs<br>[0] + 1)<br>0<br>∀i ∈ [0255] : µ<br>[0]i ≡<br>s<br>µs<br>[1]i<br>otherwise<br>[x]i gives the ith bit (counting from zero) of µs<br>[x] |   |   |                                                                                                                                                                                                                                                                                                                                                                                               |

0s: Stop and Arithmetic Operations

| SHANGHAI VERSIOI |  |
|------------------|--|
|                  |  |

| Value | Mnemonic  | δ | α | 10s: Comparison & Bitwise Logic Operations<br>Description                                                                                                                                  |  |  |
|-------|-----------|---|---|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--|--|
|       |           |   |   |                                                                                                                                                                                            |  |  |
| 0x10  | LT        | 2 | 1 | Less-than comparison.<br>(                                                                                                                                                                 |  |  |
|       |           |   |   | 1<br>if<br>µs<br>[0] < µs<br>[1]<br>0<br>µ<br>[0] ≡<br>s<br>0<br>otherwise                                                                                                                 |  |  |
| 0x11  | GT        | 2 | 1 | Greater-than comparison.                                                                                                                                                                   |  |  |
|       |           |   |   | (<br>1<br>if<br>µs<br>[0] > µs<br>[1]<br>0<br>µ<br>[0] ≡<br>s<br>0<br>otherwise                                                                                                            |  |  |
| 0x12  | SLT       | 2 | 1 | Signed less-than comparison.                                                                                                                                                               |  |  |
|       |           |   |   | (<br>1<br>if<br>µs<br>[0] < µs<br>[1]<br>0<br>[0] ≡<br>µ<br>s<br>0<br>otherwise                                                                                                            |  |  |
|       |           |   |   | Where all values are treated as two's complement signed 256-bit integers.                                                                                                                  |  |  |
| 0x13  | SGT       | 2 | 1 | Signed greater-than comparison.                                                                                                                                                            |  |  |
|       |           |   |   | (<br>1<br>if<br>µs<br>[0] > µs<br>[1]<br>0<br>[0] ≡<br>µ                                                                                                                                   |  |  |
|       |           |   |   | s<br>0<br>otherwise<br>Where all values are treated as two's complement signed 256-bit integers.                                                                                           |  |  |
| 0x14  | EQ        | 2 | 1 | Equality comparison.                                                                                                                                                                       |  |  |
|       |           |   |   | (<br>1<br>if<br>µs<br>[0] = µs<br>[1]<br>0                                                                                                                                                 |  |  |
|       |           |   |   | µ<br>[0] ≡<br>s<br>0<br>otherwise                                                                                                                                                          |  |  |
| 0x15  | ISZERO    | 1 | 1 | Simple not operator.                                                                                                                                                                       |  |  |
|       |           |   |   | (<br>1<br>if<br>µs<br>[0] = 0<br>0<br>µ<br>[0] ≡<br>s                                                                                                                                      |  |  |
|       |           |   |   | 0<br>otherwise                                                                                                                                                                             |  |  |
| 0x16  | AND       | 2 | 1 | Bitwise AND operation.<br>0<br>∀i ∈ [0255] : µ<br>[0]i ≡ µs<br>[0]i ∧ µs<br>[1]i<br>s                                                                                                      |  |  |
| 0x17  | OR        | 2 | 1 | Bitwise OR operation.<br>0                                                                                                                                                                 |  |  |
|       |           |   |   | ∀i ∈ [0255] : µ<br>[0]i ≡ µs<br>[0]i ∨ µs<br>[1]i<br>s                                                                                                                                     |  |  |
| 0x18  | XOR       | 2 | 1 | Bitwise XOR operation.<br>0<br>∀i ∈ [0255] : µ<br>[0]i ≡ µs<br>[0]i ⊕ µs<br>[1]i<br>s                                                                                                      |  |  |
| 0x19  | NOT       | 1 | 1 | Bitwise NOT operation.                                                                                                                                                                     |  |  |
|       |           |   |   | (<br>1<br>if<br>µs<br>[0]i = 0<br>0<br>∀i ∈ [0255] : µ<br>[0]i ≡<br>s                                                                                                                      |  |  |
|       |           |   |   | 0<br>otherwise                                                                                                                                                                             |  |  |
| 0x1a  | BYTE      | 2 | 1 | Retrieve single byte from word.<br>(                                                                                                                                                       |  |  |
|       |           |   |   | i ≥ 248 ∧ µs<br>µs<br>[1](i−248+8µs<br>if<br>[0] < 32<br>[0])<br>0<br>∀i ∈ [0255] : µ<br>[0]i ≡<br>s<br>0<br>otherwise                                                                     |  |  |
|       |           |   |   | For the Nth byte, we count from the left (i.e. N=0 would be the most significant<br>in big endian).                                                                                        |  |  |
| 0x1b  | SHL       | 2 | 1 | Left shift operation.                                                                                                                                                                      |  |  |
|       |           |   |   | 0<br>µs<br>[0]) mod 2256<br>µ<br>[0] ≡ (µs<br>[1] × 2<br>s                                                                                                                                 |  |  |
| 0x1c  | SHR       | 2 | 1 | Logical right shift operation.<br>0<br>µs<br>[0]c<br>µ<br>[0] ≡ bµs<br>[1] ÷ 2<br>s                                                                                                        |  |  |
| 0x1d  | SAR       | 2 | 1 | Arithmetic (signed) right shift operation.<br>0                                                                                                                                            |  |  |
|       |           |   |   | µs<br>[0]c<br>[0] ≡ bµs<br>[1] ÷ 2<br>µ<br>s<br>0<br>Where µ<br>[0] and µs<br>[1] are treated as two's complement signed 256-bit integers,<br>s<br>while µs<br>[0] is treated as unsigned. |  |  |
|       |           |   |   | 20s: KECCAK256                                                                                                                                                                             |  |  |
| Value | Mnemonic  | δ | α | Description                                                                                                                                                                                |  |  |
| 0x20  | KECCAK256 | 2 | 1 | Compute Keccak-256 hash.                                                                                                                                                                   |  |  |
|       |           |   |   | 0<br>µ<br>[0] ≡ KEC(µm[µs<br>[0](µs<br>[0] + µs<br>[1] − 1)])<br>s                                                                                                                         |  |  |
|       |           |   |   | 0<br>i ≡ M(µi<br>µ<br>, µs<br>[0], µs<br>[1])                                                                                                                                              |  |  |

|       |              |   |   | 30s: Environmental Information                                                                                                                          |
|-------|--------------|---|---|---------------------------------------------------------------------------------------------------------------------------------------------------------|
| Value | Mnemonic     | δ | α | Description                                                                                                                                             |
| 0x30  | ADDRESS      | 0 | 1 | Get address of currently executing account.<br>0<br>µ<br>[0] ≡ Ia<br>s                                                                                  |
| 0x31  | BALANCE      | 1 | 1 | Get balance of the given account.                                                                                                                       |
|       |              |   |   | (<br>6= ∅<br>[0] mod 2160]b<br>[0] mod 2160]<br>σ[µs<br>if<br>σ[µs<br>0<br>[0] ≡<br>µ                                                                   |
|       |              |   |   | s<br>0<br>otherwise<br>0                                                                                                                                |
|       |              |   |   | [0] mod 2160}<br>A<br>a ≡ Aa ∪ {µs                                                                                                                      |
| 0x32  | ORIGIN       | 0 | 1 | Get execution origination address.<br>0<br>µ<br>[0] ≡ Io<br>s                                                                                           |
|       |              |   |   | This is the sender of original transaction; it is never an account with                                                                                 |
|       |              |   |   | non-empty associated code.                                                                                                                              |
| 0x33  | CALLER       | 0 | 1 | Get caller address.<br>0<br>[0] ≡ Is<br>µ<br>s                                                                                                          |
|       |              |   |   | This is the address of the account that is directly responsible for                                                                                     |
|       |              |   |   | this execution.                                                                                                                                         |
| 0x34  | CALLVALUE    | 0 | 1 | Get deposited value by the instruction/transaction responsible for<br>this execution.                                                                   |
|       |              |   |   | 0<br>µ<br>[0] ≡ Iv<br>s                                                                                                                                 |
| 0x35  | CALLDATALOAD | 1 | 1 | Get input data of current environment.<br>0                                                                                                             |
|       |              |   |   | x ><br>[0] ≡ Id[µs<br>kIdk<br>µ<br>[0](µs<br>[0] + 31)]<br>with<br>Id[x] = 0<br>if<br>s<br>This pertains to the input data passed with the message call |
|       |              |   |   | instruction or transaction.                                                                                                                             |
| 0x36  | CALLDATASIZE | 0 | 1 | Get size of input data in current                                                                                                                       |
|       |              |   |   | environment.<br>0<br>µ<br>[0] ≡ kIdk                                                                                                                    |
|       |              |   |   | s<br>This pertains to the input data passed with the message call                                                                                       |
|       |              |   |   | instruction or transaction.                                                                                                                             |
| 0x37  | CALLDATACOPY | 3 | 0 | Copy input data in current environment to memory.<br>(<br>[1] + i]<br>if                                                                                |
|       |              |   |   | Id[µs<br>µs<br>[1] + i < kIdk<br>0<br>∀i ∈ {0 µs<br>[2] − 1} : µ<br>m[µs<br>[0] + i] ≡<br>0<br>otherwise                                                |
|       |              |   |   | [1] + i are not subject to the 2256 modulo.<br>The additions in µs                                                                                      |
|       |              |   |   | 0<br>µ<br>i ≡ M(µi<br>, µs<br>[0], µs<br>[2])<br>This pertains to the input data passed with the message call instruction                               |
|       |              |   |   | or transaction.                                                                                                                                         |
| 0x38  | CODESIZE     | 0 | 1 | Get size of code running in current environment.<br>0                                                                                                   |
|       |              |   |   | µ<br>[0] ≡ kIbk<br>s                                                                                                                                    |
| 0x39  | CODECOPY     | 3 | 0 | Copy code running in current environment to memory.<br>(<br>[1] + i < kIbk<br>Ib[µs<br>[1] + i]<br>if<br>µs                                             |
|       |              |   |   | 0<br>∀i ∈ {0 µs<br>[2] − 1} : µ<br>m[µs<br>[0] + i] ≡<br>otherwise<br>STOP                                                                              |
|       |              |   |   | 0<br>µ<br>i ≡ M(µi<br>, µs<br>[0], µs<br>[2])                                                                                                           |
|       |              |   |   | [1] + i are not subject to the 2256 modulo.<br>The additions in µs                                                                                      |
| 0x3a  | GASPRICE     | 0 | 1 | Get price of gas in current environment.<br>This is the effective gas price defined in section 6.                                                       |
|       |              |   |   | Note that as of the London hard fork, this value no longer                                                                                              |
|       |              |   |   | represents what is received by the validator,<br>but rather just what is paid by the sender.                                                            |
|       |              |   |   | 0<br>µ<br>[0] ≡ Ip<br>s                                                                                                                                 |
| 0x3b  | EXTCODESIZE  | 1 | 1 | Get size of an account's code.                                                                                                                          |
|       |              |   |   | (<br>6= ∅<br>[0] mod 2160]<br>kbk<br>if<br>σ[µs<br>0<br>µ<br>[0] ≡<br>s                                                                                 |
|       |              |   |   | 0<br>otherwise<br>[0] mod 2160]c<br>where KEC(b) ≡ σ[µs                                                                                                 |
|       |              |   |   | 0<br>[0] mod 2160}<br>a ≡ Aa ∪ {µs<br>A                                                                                                                 |
| 0x3c  | EXTCODECOPY  | 4 | 0 | Copy an account's code to memory.<br>(                                                                                                                  |
|       |              |   |   | b[µs<br>[2] + i]<br>if<br>µs<br>[2] + i < kbk<br>0<br>∀i ∈ {0 µs<br>[3] − 1} : µ<br>m[µs<br>[1] + i] ≡<br>otherwise<br>STOP                             |
|       |              |   |   | [0] mod 2160]c<br>where KEC(b) ≡ σ[µs<br>∅.<br>[0] mod 2160] =<br>We assume b ≡ () if σ[µs                                                              |
|       |              |   |   | 0<br>µ<br>i ≡ M(µi<br>, µs<br>[1], µs<br>[3])                                                                                                           |
|       |              |   |   | [2] + i are not subject to the 2256 modulo.<br>The additions in µs<br>0<br>[0] mod 2160}<br>A<br>a ≡ Aa ∪ {µs                                           |

<span id="page-33-0"></span>

| 0x3d  | RETURNDATASIZE |   | 0 | 1<br>Get size of output data from the previous call from the current<br>environment.<br>0<br>µ<br>[0] ≡ kµok<br>s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |  |
|-------|----------------|---|---|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--|
| 0x3e  | RETURNDATACOPY |   | 3 | 0<br>Copy output data from the previous call to memory.<br>(<br>[1] + i < kµok<br>µo<br>[µs<br>[1] + i]<br>if<br>µs<br>0<br>∀i ∈ {0 µs<br>[2] − 1} : µ<br>[0] + i] ≡<br>m[µs<br>0<br>otherwise<br>[1] + i are not subject to the 2256 modulo.<br>The additions in µs<br>0<br>µ<br>i ≡ M(µi<br>, µs<br>[0], µs<br>[2])                                                                                                                                                                                                                                                                                                                      |  |
| 0x3f  | EXTCODEHASH    |   | 1 | 1<br>Get hash of an account's code.<br>(<br>[0] mod 2160)<br>0<br>if<br>DEAD(σ, µs<br>0<br>µ<br>[0] ≡<br>s<br>[0] mod 2160]c<br>σ[µs<br>otherwise<br>0<br>[0] mod 2160}<br>A<br>a ≡ Aa ∪ {µs                                                                                                                                                                                                                                                                                                                                                                                                                                               |  |
|       |                |   |   | 40s: Block Information                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |  |
| Value | Mnemonic       | δ | α | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |  |
| 0x40  | BLOCKHASH      | 1 | 1 | Get the hash of one of the 256 most recent complete blocks.<br>0<br>µ<br>[0] ≡ P(IHp<br>, µs<br>[0], 0)<br>s<br>where P is the hash of a block of a particular number, up to a maximum<br>age. 0 is left on the stack if the looked for block number is greater than or<br>equal to the current block number or more than 256 blocks behind the current block.<br><br>0<br>if<br>n > Hi ∨ a = 256 ∨ h = 0<br><br>P(h, n, a) ≡<br>h<br>if<br>n = Hi<br><br>P(Hp, n, a + 1)<br>otherwise<br>and we assert the header H can be determined from its hash h unless h is zero<br>(as is the case for the parent hash of the genesis block). |  |
| 0x41  | COINBASE       | 0 | 1 | Get the current block's beneficiary address.<br>0<br>µ<br>[0] ≡ IHc<br>s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |  |
| 0x42  | TIMESTAMP      | 0 | 1 | Get the current block's timestamp.<br>0<br>µ<br>[0] ≡ IHs<br>s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |  |
| 0x43  | NUMBER         | 0 | 1 | Get the current block's number.<br>0<br>µ<br>[0] ≡ IHi<br>s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |  |
| 0x44  | PREVRANDAO     | 0 | 1 | Get the latest RANDAO mix of the post beacon state of the previous block.<br>0<br>[0] ≡ IHa<br>µ<br>s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |  |
| 0x45  | GASLIMIT       | 0 | 1 | Get the current block's gas limit.<br>0<br>µ<br>[0] ≡ IHl<br>s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |  |
| 0x46  | CHAINID        | 0 | 1 | Get the chain ID.<br>0<br>µ<br>[0] ≡ β<br>s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |  |
| 0x47  | SELFBALANCE    | 0 | 1 | Get balance of currently executing account.<br>0<br>µ<br>[0] ≡ σ[Ia]b<br>s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |  |
| 0x48  | BASEFEE        | 0 | 1 | Get the current block's base fee.<br>0<br>µ<br>[0] ≡ IHf<br>s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |  |

<span id="page-34-3"></span><span id="page-34-2"></span><span id="page-34-1"></span><span id="page-34-0"></span>

|       |          | 50s: Stack, Memory, Storage and Flow Operations |   |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |  |  |
|-------|----------|-------------------------------------------------|---|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--|--|
| Value | Mnemonic | δ                                               | α | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |  |  |
| 0x50  | POP      | 1                                               | 0 | Remove item from stack.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |  |  |
| 0x51  | MLOAD    | 1                                               | 1 | Load word from memory.<br>0<br>µ<br>[0] ≡ µm[µs<br>[0](µs<br>[0] + 31)]<br>s<br>0<br>µ<br>i ≡ max(µi<br>, d(µs<br>[0] + 32) ÷ 32e)<br>0<br>is not subject to the 2256 modulo.<br>The addition in the calculation of µ<br>i                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |  |  |
| 0x52  | MSTORE   | 2                                               | 0 | Save word to memory.<br>0<br>[0] + 31)] ≡ µs<br>µ<br>m[µs<br>[0](µs<br>[1]<br>0<br>µ<br>i ≡ max(µi<br>, d(µs<br>[0] + 32) ÷ 32e)<br>0<br>is not subject to the 2256 modulo.<br>The addition in the calculation of µ<br>i                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |  |  |
| 0x53  | MSTORE8  | 2                                               | 0 | Save byte to memory.<br>0<br>[0]] ≡ (µs<br>µ<br>m[µs<br>[1] mod 256)<br>0<br>µ<br>i ≡ max(µi<br>, d(µs<br>[0] + 1) ÷ 32e)<br>0<br>is not subject to the 2256 modulo.<br>The addition in the calculation of µ<br>i                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |  |  |
| 0x54  | SLOAD    | 1                                               | 1 | Load word from storage.<br>0<br>µ<br>[0] ≡ σ[Ia]s[µs<br>[0]]<br>s<br>0<br>A<br>K ≡ AK ∪ {(Ia, µs<br>[0])}<br>(<br>[0]) ∈ AK<br>Gwarmaccess<br>if<br>(Ia, µs<br>CSLOAD(µ, A, I) ≡<br>Gcoldsload<br>otherwise                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |  |  |
| 0x55  | SSTORE   | 2                                               | 0 | Save word to storage.<br>0<br>σ<br>[Ia]s[µs<br>[0]] ≡ µs<br>[1]<br>0<br>A<br>K ≡ AK ∪ {(Ia, µs<br>[0])}<br>0<br>CSSTORE(σ, µ) and A<br>r are specified by EIP-2200 as follows.<br>We remind the reader that the checkpoint ("original") state σ0 is the state<br>if the current transaction were to revert.<br>Let v0 = σ0[Ia]s[µs<br>[0]] be the original value of the storage slot.<br>Let v = σ[Ia]s[µs<br>[0]] be the current value.<br>0 =<br>Let v<br>µs<br>[1] be the new value.<br>Then:<br>(<br>0<br>if<br>(Ia, µs<br>[0]) ∈ AK<br>CSSTORE(σ, µ, A, I) ≡<br>Gcoldsload<br>otherwise<br><br>0 ∨<br>Gwarmaccess<br>if<br>v = v<br>v0 6= v<br><br>0 ∧<br>+<br>Gsset<br>if<br>v 6= v<br>v0 = v ∧ v0 = 0<br><br>0 ∧<br>Gsreset<br>if<br>v 6= v<br>v0 = v ∧ v0 6= 0<br><br>0 ∧<br>0 = 0<br>Rsclear<br>if<br>v 6= v<br>v0 = v ∧ v<br><br>0<br>0 ∧<br>r ≡ Ar +<br>A<br>rdirtyclear + rdirtyreset<br>if<br>v 6= v<br>v0 6= v<br><br>0<br>otherwise<br>where<br><br>−Rsclear<br>if<br>v0 6= 0 ∧ v = 0<br><br>0 = 0<br>rdirtyclear ≡<br>Rsclear<br>if<br>v0 6= 0 ∧ v<br><br>0<br>otherwise<br><br>0 ∧<br>Gsset − Gwarmaccess<br>if<br>v0 = v<br>v0 = 0<br><br>0 ∧<br>rdirtyreset ≡<br>Gsreset − Gwarmaccess<br>if<br>v0 = v<br>v0 6= 0<br><br>0<br>otherwise |  |  |
| 0x56  | JUMP     | 1                                               | 0 | Alter the program counter.<br>JJUMP(µ) ≡ µs<br>[0]<br>This has the effect of writing said value to µpc. See section 9.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |  |  |
| 0x57  | JUMPI    | 2                                               | 0 | Conditionally alter the program counter.<br>(<br>µs<br>[0]<br>if<br>µs<br>[1] 6= 0<br>JJUMPI(µ) ≡<br>µpc<br>+ 1<br>otherwise<br>This has the effect of writing said value to µpc. See section 9.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |  |  |
| 0x58  | PC       | 0                                               | 1 | Get the value of the program counter prior to the increment<br>corresponding to this instruction.<br>0<br>µ<br>[0] ≡ µpc<br>s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |  |  |

| 0x59  | MSIZE    | 0                                                                                                                                                                           | 1  | 0<br>µ           | Get the size of active memory in bytes.<br>[0] ≡ 32µi                                                                                                                                                                                                  |  |  |
|-------|----------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----|------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--|--|
| 0x5a  | GAS      | 0                                                                                                                                                                           | 1  | s<br>0<br>µ<br>s | Get the amount of available gas, including the corresponding reduction<br>for the cost of this instruction.<br>[0] ≡ µg                                                                                                                                |  |  |
| 0x5b  | JUMPDEST | 0                                                                                                                                                                           | 0  |                  | Mark a valid destination for jumps.<br>This operation has no effect on machine state during execution.                                                                                                                                                 |  |  |
|       |          |                                                                                                                                                                             |    |                  | 5f, 60s & 70s: Push Operations                                                                                                                                                                                                                         |  |  |
| Value | Mnemonic |                                                                                                                                                                             | δ  | α                | Description                                                                                                                                                                                                                                            |  |  |
| 0x5f  | PUSH0    |                                                                                                                                                                             | 0  | 1                | Place 0 on the stack.<br>0<br>µ<br>[0] ≡ 0<br>s                                                                                                                                                                                                        |  |  |
| 0x60  | PUSH1    |                                                                                                                                                                             | 0  | 1                | Place 1 byte item on stack.<br>0<br>[0] ≡ c(µpc<br>µ<br>+ 1)<br>s                                                                                                                                                                                      |  |  |
|       |          |                                                                                                                                                                             |    |                  | (<br>Ib[x]<br>if<br>x < kIbk<br>where<br>c(x) ≡                                                                                                                                                                                                        |  |  |
|       |          |                                                                                                                                                                             |    |                  | 0<br>otherwise<br>The bytes are read in line from the program code's bytes array.<br>The function c ensures the bytes default to zero if they extend past the limits.<br>The byte is right-aligned (takes the lowest significant place in big endian). |  |  |
| 0x61  | PUSH2    |                                                                                                                                                                             | 0  | 1                | Place 2-byte item on stack.                                                                                                                                                                                                                            |  |  |
|       |          |                                                                                                                                                                             |    |                  | 0<br><br>+ 2)<br>µ<br>[0] ≡ c<br>(µpc<br>+ 1).(µpc<br>s                                                                                                                                                                                                |  |  |
|       |          |                                                                                                                                                                             |    |                  | with c(x) ≡ (c(x0), , c(xkxk−1)) with c as defined as above.<br>The bytes are right-aligned (takes the lowest significant place in big endian).                                                                                                        |  |  |
|       |          |                                                                                                                                                                             |    |                  |                                                                                                                                                                                                                                                        |  |  |
| 0x7f  | PUSH32   |                                                                                                                                                                             | 0  | 1                | Place 32-byte (full word) item on stack.                                                                                                                                                                                                               |  |  |
|       |          | 0<br><br>+ 32)<br>µ<br>[0] ≡ c<br>(µpc<br>+ 1).(µpc<br>s<br>where c is defined as above.<br>The bytes are right-aligned (takes the lowest significant place in big endian). |    |                  |                                                                                                                                                                                                                                                        |  |  |
|       |          |                                                                                                                                                                             |    |                  | 80s: Duplication Operations                                                                                                                                                                                                                            |  |  |
| Value | Mnemonic |                                                                                                                                                                             | δ  | α                | Description                                                                                                                                                                                                                                            |  |  |
| 0x80  | DUP1     |                                                                                                                                                                             | 1  | 2                | Duplicate 1st stack item.<br>0<br>[0] ≡ µs<br>µ<br>[0]<br>s                                                                                                                                                                                            |  |  |
| 0x81  | DUP2     |                                                                                                                                                                             | 2  | 3                | Duplicate 2nd stack item.<br>0<br>µ<br>[0] ≡ µs<br>[1]<br>s                                                                                                                                                                                            |  |  |
|       |          |                                                                                                                                                                             |    |                  |                                                                                                                                                                                                                                                        |  |  |
| 0x8f  | DUP16    |                                                                                                                                                                             | 16 | 17               | Duplicate 16th stack item.<br>0<br>µ<br>[0] ≡ µs<br>[15]<br>s                                                                                                                                                                                          |  |  |
|       |          |                                                                                                                                                                             |    |                  | 90s: Exchange Operations                                                                                                                                                                                                                               |  |  |
| Value | Mnemonic |                                                                                                                                                                             |    |                  |                                                                                                                                                                                                                                                        |  |  |
| 0x90  |          |                                                                                                                                                                             | δ  | α                | Description                                                                                                                                                                                                                                            |  |  |
|       | SWAP1    |                                                                                                                                                                             | 2  | 2                | Exchange 1st and 2nd stack items.<br>0<br>[0] ≡ µs<br>µ<br>[1]<br>s<br>0<br>µ<br>[1] ≡ µs<br>[0]<br>s                                                                                                                                                  |  |  |
| 0x91  | SWAP2    |                                                                                                                                                                             | 3  | 3                | Exchange 1st and 3rd stack items.<br>0<br>µ<br>[0] ≡ µs<br>[2]<br>s<br>0<br>µ<br>[2] ≡ µs<br>[0]<br>s                                                                                                                                                  |  |  |
|       |          |                                                                                                                                                                             |    |                  |                                                                                                                                                                                                                                                        |  |  |
| 0x9f  | SWAP16   |                                                                                                                                                                             | 17 | 17               | Exchange 1st and 17th stack items.<br>0<br>[0] ≡ µs<br>µ<br>[16]<br>s<br>0<br>µ<br>[16] ≡ µs<br>[0]<br>s                                                                                                                                               |  |  |

#### a0s: Logging Operations

For all logging operations, the state change is to append an additional log entry on to the substate's log series: A 0 <sup>l</sup> ≡ A<sup>l</sup> · (Ia, t, µm[µ<sup>s</sup> [0] . . .(µ<sup>s</sup> [0] + µ<sup>s</sup> [1] − 1)]) and to update the memory consumption counter:

µ 0 <sup>i</sup> ≡ M(µ<sup>i</sup> , µ<sup>s</sup> [0], µ<sup>s</sup> [1])

The entry's topic series, t, differs accordingly:

| Value | Mnemonic | δ | α | Description                                                                             |  |
|-------|----------|---|---|-----------------------------------------------------------------------------------------|--|
| 0xa0  | LOG0     | 2 | 0 | Append log record with no topics.<br>t ≡ ()                                             |  |
| 0xa1  | LOG1     | 3 | 0 | Append log record with one topic.<br>t ≡ (µs<br>[2])                                    |  |
|       |          |   |   |                                                                                         |  |
| 0xa4  | LOG4     | 6 | 0 | Append log record with four topics.<br>t ≡ (µs<br>[2], µs<br>[3], µs<br>[4], µs<br>[5]) |  |

<span id="page-37-0"></span>

| f0s: System operations |          |   |   |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |  |
|------------------------|----------|---|---|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--|
| Value                  | Mnemonic | δ | α | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |  |
| 0xf0                   | CREATE   | 3 | 1 | Create a new account with associated code.<br>i ≡ µm[µs<br>[1](µs<br>[1] + µs<br>[2] − 1)]<br>ζ ≡ ∅                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |  |
|                        |          |   |   | <br>[0] 6<br>∗<br>Λ(σ<br>, A, Ia, Io, L(µg<br>), Ip, µs<br>[0], i, Ie + 1, ζ, Iw)<br>if<br>µs<br>σ[Ia]b ∧<br><br>0<br>, g0<br>, A0<br>Ie < 1024 ∧ kik 6<br>, z, o) ≡<br>(σ<br>49152<br><br><br>), A, 0,()<br>σ, L(µg<br>otherwise<br>∗ ≡<br>∗<br>σ<br>σ<br>except<br>σ<br>[Ia]n = σ[Ia]n + 1<br>0<br>0<br>µ<br>g ≡ µg<br>− L(µg<br>) + g<br>0<br>µ<br>[0] ≡ x<br>s<br>where x = 0 if z = 0, i.e., the contract creation process failed,<br>or kik > 49152 (initcode is longer than 49152 bytes),<br>or Ie = 1024 (the maximum call depth limit is reached),<br>or µs<br>[0] > σ[Ia]b (balance of the caller is too low to fulfil the value transfer);<br>and otherwise x = ADDR(Ia, σ[Ia]n, ζ, i), the address of the newly created account (95).<br>0<br>i ≡ M(µi<br>µ<br>, µs<br>[1], µs<br>[2])<br>(<br>()<br>if<br>z = 1<br>0<br>µ<br>o ≡<br>o<br>otherwise<br>Thus the operand order is: value, input offset, input size.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |  |
| 0xf1                   | CALL     | 7 | 1 | Message-call into an account.<br>i ≡ µm[µs<br>[3](µs<br>[3] + µs<br>[4] − 1)]<br>[2] 6<br><br>Θ(σ, A∗<br>σ[Ia]b ∧<br>, Ia, Io, t, t, CCALLGAS(σ, µ, A),<br>if<br>µs<br><br>0<br>, g0<br>, A0<br>(σ<br>, x, o) ≡<br>Ip, µs<br>[2], µs<br>[2], i, Ie + 1, Iw)<br>Ie < 1024<br>(σ, CCALLGAS(σ, µ, A), A∗<br><br>, 0,())<br>otherwise<br>n ≡ min({µs<br>[6], kok})<br>0<br>µ<br>m[µs<br>[5](µs<br>[5] + n − 1)] = o[0(n − 1)]<br>0<br>µ<br>o = o<br>0<br>0<br>g ≡ µg<br>− CCALLGAS(σ, µ, A) + g<br>µ<br>0<br>µ<br>[0] ≡ x<br>s<br>∗ ≡<br>∗<br>a ≡ Aa ∪ {t}<br>A<br>A<br>except<br>A<br>[1] mod 2160<br>t ≡ µs<br>0<br>µ<br>i ≡ M(M(µi<br>, µs<br>[3], µs<br>[4]), µs<br>[5], µs<br>[6])<br>where x = 0 if the code execution for this operation failed, or if<br>µs<br>[2] > σ[Ia]b (not enough funds) or Ie = 1024 (call depth limit reached); x = 1<br>otherwise.<br>Thus the operand order is: gas, to, value, in offset, in size, out offset, out size.<br>CCALL(σ, µ, A) ≡ CGASCAP(σ, µ, A) + CEXTRA(σ, µ, A)<br>(<br>[2] 6= 0<br>CGASCAP(σ, µ, A) + Gcallstipend<br>if<br>µs<br>CCALLGAS(σ, µ, A) ≡<br>CGASCAP(σ, µ, A)<br>otherwise<br>(<br>min{L(µg<br>− CEXTRA(σ, µ, A)), µs<br>[0]}<br>if<br>µg<br>≥ CEXTRA(σ, µ, A)<br>CGASCAP(σ, µ, A) ≡<br>µs<br>[0]<br>otherwise<br>CEXTRA(σ, µ, A) ≡ Caaccess(t, A) + CXFER(µ) + CNEW(σ, µ)<br>(<br>Gcallvalue<br>if<br>µs<br>[2] 6= 0<br>CXFER(µ) ≡<br>0<br>otherwise<br>(<br>Gnewaccount<br>if<br>DEAD(σ, t) ∧ µs<br>[2] 6= 0<br>CNEW(σ, µ) ≡<br>0<br>otherwise |  |
| 0xf2                   | CALLCODE | 7 | 1 | Message-call into this account with an alternative account's code.<br>Exactly equivalent to CALL except:<br><br>[2] 6<br>Θ(σ, A∗<br>, Ia, Io, Ia, t, CCALLGAS(σ, µ, A),<br>if<br>µs<br>σ[Ia]b ∧<br><br>0<br>, g0<br>, A0<br>, x, o) ≡<br>(σ<br>Ip, µs<br>[2], µs<br>[2], i, Ie + 1, Iw)<br>Ie < 1024<br>(σ, CCALLGAS(σ, µ, A), A∗<br><br>, 0,())<br>otherwise<br>Note the change in the fourth parameter to the call Θ from the 2nd stack value<br>µs<br>[1] (as in CALL) to the present address Ia. This means that the recipient is in<br>fact the same account as at present, simply that the code is overwritten.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |  |
| 0xf3                   | RETURN   | 2 | 0 | Halt execution returning output data.<br>HRETURN(µ) ≡ µm[µs<br>[1] − 1)]<br>[0](µs<br>[0] + µs<br>This has the effect of halting the execution at this point with output defined.<br>See section 9.<br>0<br>i ≡ M(µi<br>µ<br>, µs<br>[0], µs<br>[1])                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |  |

<span id="page-38-2"></span><span id="page-38-1"></span>

| 0xf4 | DELEGATECALL | 6 | 1 | Message-call into this account with an alternative account's code, but<br>persisting the current values for sender and value.<br>Compared with CALL, DELEGATECALL takes one fewer arguments. The<br>omitted argument is µs<br>[2]. As a result, µs<br>[3], µs<br>[4], µs<br>[5] and µs<br>[6] in the<br>definition of CALL should respectively be replaced with µs<br>[2], µs<br>[3], µs<br>[4] and<br>µs<br>[5]. Otherwise it is equivalent to CALL except:<br><br>Θ(σ, A∗<br>, Is, Io, Ia, t, CCALLGAS(σ, µ, A),<br><br>if<br>Ie < 1024<br>0<br>, g0<br>, A0<br>(σ<br>, x, o) ≡<br>Ip, 0, Iv, i, Ie + 1, Iw)<br>(σ, CCALLGAS(σ, µ, A), A∗<br><br>, 0,())<br>otherwise<br>Note the changes (in addition to that of the fourth parameter) to the second<br>and ninth parameters to the call Θ.<br>This means that the recipient is in fact the same account as at present, simply<br>that the code is overwritten and the context is almost entirely identical. |
|------|--------------|---|---|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 0xf5 | CREATE2      | 4 | 1 | Create a new account with associated code.<br>Exactly equivalent to CREATE except:<br>The salt ζ ≡ µs<br>[3].                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| 0xfa | STATICCALL   | 6 | 1 | Static message-call into an account.<br>Exactly equivalent to CALL except:<br>The argument µs<br>[2] is replaced with 0.<br>The deeper argument µs<br>[3], µs<br>[4], µs<br>[5] and µs<br>[6] are respectively replaced<br>with µs<br>[2], µs<br>[3], µs<br>[4] and µs<br>[5].<br>The last argument of Θ is ⊥.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| 0xfd | REVERT       | 2 | 0 | Halt execution reverting state changes but returning data and remaining gas.<br>HRETURN(µ) ≡ µm[µs<br>[0](µs<br>[0] + µs<br>[1] − 1)]<br>The effect of this operation is described in (152).<br>For the gas calculation, we use the memory expansion function,<br>0<br>i ≡ M(µi<br>µ<br>, µs<br>[0], µs<br>[1])                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| 0xfe | INVALID      | ∅ | ∅ | Designated invalid instruction.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| 0xff | SELFDESTRUCT | 1 | 0 | Halt execution and register account for later deletion. Readers should be warned,<br>since the Shanghai update, this opcode has been marked as deprecated.<br>Its behavior might be subject to breaking change in an upcoming update.<br>0<br>s ≡ As ∪ {Ia}<br>A<br>0<br>A<br>a ≡ Aa ∪ {r}<br><br>∅<br>σ[r] = ∅<br>if<br>∧ σ[Ia]b = 0<br><br>0<br>σ<br>[r] ≡<br>(σ[r]n, σ[r]b + σ[Ia]b, σ[r]s, σ[r]c)<br>if<br>r 6= Ia<br><br>(σ[r]n, 0, σ[r]s, σ[r]c)<br>otherwise<br>[0] mod 2160<br>where r = µs<br>0<br>σ<br>[Ia]b = 0<br>(<br>0<br>if<br>r ∈ Aa<br>CSELFDESTRUCT(σ, µ) ≡ Gselfdestruct +<br>Gcoldaccountaccess<br>otherwise<br>(<br>Gnewaccount<br>if<br>DEAD(σ, r) ∧ σ[Ia]b 6= 0<br>+<br>0<br>otherwise                                                                                                                                                                                                                                                   |

Appendix I. Genesis Block

<span id="page-38-3"></span><span id="page-38-0"></span>The genesis block is 15 items, and is specified thus:

(333) 0256, KEC RLP (), 0160, stateRoot, 0, 0, 02048, 2 34 , 0, 0, 3141592, time, 0, 0256, KEC (42),(),()

Where 0<sup>256</sup> refers to the parent hash, a 256-bit hash which is all zeroes; 0<sup>160</sup> refers to the beneficiary address, a 160-bit hash which is all zeroes; 0<sup>2048</sup> refers to the log bloom, 2048-bit of all zeros; 2<sup>34</sup> refers to the difficulty; the transaction trie root, receipt trie root, gas used, block number and extradata are both 0, being equivalent to the empty byte array. The sequences of both ommers and transactions are empty and represented by (). KEC (42) refers to the Keccak-256 hash of a byte array of length one whose first and only byte is of value 42, used for the nonce. KEC RLP () value refers to the hash of the ommer list in RLP, both empty lists.

The proof-of-concept series include a development premine, making the state root hash some value stateRoot. Also time will be set to the initial timestamp of the genesis block. The latest documentation should be consulted for those values.

### Appendix J. Ethash

J.1. Deprecation. This section is kept for historical purposes, but the Ethash algorithm is no longer used for consensus as of the Paris hard fork.

| Name           | Value   | Description                                |
|----------------|---------|--------------------------------------------|
| Jwordbytes     | 4       | Bytes in word.                             |
| Jdatasetinit   | 30<br>2 | Bytes in dataset at genesis.               |
| Jdatasetgrowth | 23<br>2 | Dataset growth per epoch.                  |
| Jcacheinit     | 24<br>2 | Bytes in cache at genesis.                 |
| Jcachegrowth   | 17<br>2 | Cache growth per epoch.                    |
| Jepoch         | 30000   | Blocks per epoch.                          |
| Jmixbytes      | 128     | mix length in bytes.                       |
| Jhashbytes     | 64      | Hash length in bytes.                      |
| Jparents       | 256     | Number of parents of each dataset element. |
| Jcacherounds   | 3       | Number of rounds in cache production.      |
| Jaccesses      | 64      | Number of accesses in hashimoto loop.      |

J.2. Definitions. We employ the following definitions:

J.3. Size of dataset and cache. The size for Ethash's cache c ∈ B and dataset d ∈ B depend on the epoch, which in turn depends on the block number.

$$(334)\tag{334}$$

$$E\_{\text{epoch}}(H\_{\text{l}}) = \left\lfloor \frac{H\_{\text{l}}}{J\_{\text{epoch}}} \right\rfloor$$

The size of the dataset growth by Jdatasetgrowth bytes, and the size of the cache by Jcachegrowth bytes, every epoch. In order to avoid regularity leading to cyclic behavior, the size must be a prime number. Therefore the size is reduced by a multiple of Jmixbytes, for the dataset, and Jhashbytes for the cache. Let dsize = kdk be the size of the dataset. Which is calculated using

$$(335)\qquad d\_{\text{slue}} = E\_{\text{prlma}}(J\_{\text{datasatnitt}} + J\_{\text{datasatgrowth}} \cdot E\_{\text{epoch}} - J\_{\text{mikytyas}}, J\_{\text{mikytyas}})$$

The size of the cache, csize, is calculated using

(336) csize = Eprime(Jcacheinit + Jcachegrowth · Eepoch − Jhashbytes, Jhashbytes)

$$\begin{array}{cc} \text{(337)} & E\_{\text{prima}}(x, y) = \begin{cases} x & \text{if} \\ E\_{\text{prime}}(x - 2 \cdot y, y) & \text{otherwise} \end{cases} \end{array}$$

J.4. Dataset generation. In order to generate the dataset we need the cache c, which is an array of bytes. It depends on the cache size csize and the seed hash s ∈ B32.

J.4.1. Seed hash. The seed hash is different for every epoch. For the first epoch it is the Keccak-256 hash of a series of 32 bytes of zeros. For every other epoch it is always the Keccak-256 hash of the previous seed hash:

$$\begin{pmatrix} \text{338} \\ \end{pmatrix} \tag{338}$$

$$(339) \qquad \qquad C\_{\text{soodhaah}}(H\_l) = \begin{cases} \mathbf{0}\_{32} & \text{if } \quad E\_{\text{epoch}}(H\_l) = 0 \\ \mathbf{KEC}(C\_{\text{soodhaah}}(H\_l - J\_{\text{epoch}})) & \text{otherwise} \end{cases}$$

With 0<sup>32</sup> being 32 bytes of zeros.

J.4.2. Cache. The cache production process involves using the seed hash to first sequentially filling up csize bytes of memory, then performing Jcacherounds passes of the RandMemoHash algorithm created by [Lerner \[2014\]](#page-17-19). The initial cache c 0 , being an array of arrays of single bytes, will be constructed as follows.

We define the array ci, consisting of 64 single bytes, as the ith element of the initial cache:

$$\mathbf{c}\_{i} = \begin{cases} \texttt{KEC512}(\mathbf{s}) & \text{if} \quad i = 0 \\ \texttt{KEC512}(\mathbf{c}\_{i-1}) & \text{otherwise} \end{cases}$$

Therefore c 0 can be defined as

(341) c 0 [i] = c<sup>i</sup> ∀ i < n

$$(342) \tag{342}$$

The cache is calculated by performing Jcacherounds rounds of the RandMemoHash algorithm to the initial cache c 0 :

$$\begin{array}{cc} \text{(343)} & \mathbf{c} = E\_{\text{cachorounds}} \text{(c}^{\prime}, J\_{\text{cachorrounds}}\text{)} \end{array}$$

ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER SHANGHAI VERSION 41

$$\begin{aligned} \text{(344)}\\ \text{(344)}\\ \text{(34)} \end{aligned} \qquad E\_{\text{achero}\\ \text{(x,y)}} = \begin{cases} \text{x} & \text{if} \quad y = 0\\ E\_{\text{RMH}}(\mathbf{x}) & \text{if} \quad y = 1\\ E\_{\text{achero}\\ \text{(x,y)}} \left( E\_{\text{RMH}}(\mathbf{x}), y - 1 \right) & \text{otherwise} \end{cases} \tag{35}$$

Where a single round modifies each subset of the cache as follows:

$$\begin{pmatrix} \text{(345)}\\ \text{(345)} \end{pmatrix} \qquad \qquad E\_{\text{RMH}}(\mathbf{x}) = \left( E\_{\text{rmh}}(\mathbf{x}, 0), E\_{\text{rmh}}(\mathbf{x}, 1), \dots, E\_{\text{rmh}}(\mathbf{x}, n - 1) \right)$$

(346) Ermh(x, i) = KEC512(x 0 [(i − 1 + n) mod n] ⊕ x 0 [x 0 [i][0] mod n])

$$\text{with} \quad \mathbf{x}' = \mathbf{x} \quad \text{except} \quad \mathbf{x}'[j] = E\_{\text{rmh}}(\mathbf{x}, j) \quad \forall \quad j < i$$

<span id="page-40-0"></span>J.4.3. Full dataset calculation. Essentially, we combine data from Jparents pseudorandomly selected cache nodes, and hash that to compute the dataset. The entire dataset is then generated by a number of items, each Jhashbytes bytes in size:

$$\mathbf{d}[i] = E\_{\text{datasettime}}(\mathbf{c}, i) \quad \forall \quad i < \left\lfloor \frac{d\_{\text{bias}}}{J\_{\text{hashyts}}} \right\rfloor$$

In order to calculate the single item we use an algorithm inspired by the FNV hash [\(Glenn Fowler \[1991\]](#page-17-20)) in some cases as a non-associative substitute for XOR.

$$(348) \newline \qquad \qquad E\_{\rm FNV}(\mathbf{x}, \mathbf{y}) = (\mathbf{x} \cdot (0 \mathbf{x} 01000193 \oplus \mathbf{y})) \bmod 2^{32}$$

The single item of the dataset can now be calculated as:

$$\begin{array}{cc} \text{(349)} & E\_{\text{datasotitem}}(\mathbf{c}, i) = E\_{\text{parents}}(\mathbf{c}, i, -1, \mathcal{D}) \end{array}$$

$$\begin{aligned} \text{(350)} \qquad \qquad E\_{\text{parents}}(\mathbf{c}, i, p, \mathbf{m}) = \begin{cases} E\_{\text{parents}}(\mathbf{c}, i, p+1, E\_{\text{mix}}(\mathbf{m}, \mathbf{c}, i, p+1)) & \text{if} \quad p < J\_{\text{parents}} - 2 \\ E\_{\text{mix}}(\mathbf{m}, \mathbf{c}, i, p+1) & \text{otherwise} \end{cases} \end{aligned} \tag{35}$$

$$\mathbf{c}(351) \qquad \qquad E\_{\rm mix}(\mathbf{m}, \mathbf{c}, i, p) = \begin{cases} \mathbf{k} \mathbf{E} \mathbf{G} \mathbf{1} \mathbf{2} \{ \mathbf{c}[i \bmod c\_{\rm idea}] \oplus i \} & \text{if} \quad p = 0 \\ E\_{\rm FN} \left( \mathbf{m}, \mathbf{c} [E\_{\rm FN}(i \oplus p, \mathbf{m}[p \bmod \lfloor J\_{\rm hashytya}/J\_{\rm wouldtyts}])] \bmod c\_{\rm idea} \right) & \text{otherwise} \end{cases}$$

J.5. Proof-of-work function. Essentially, we maintain a "mix" Jmixbytes bytes wide, and repeatedly sequentially fetch Jmixbytes bytes from the full dataset and use the EFNV function to combine it with the mix. Jmixbytes bytes of sequential access are used so that each round of the algorithm always fetches a full page from RAM, minimizing translation lookaside buffer misses which ASICs would theoretically be able to avoid.

If the output of this algorithm is below the desired target, then the nonce is valid. Note that the extra application of KEC at the end ensures that there exists an intermediate nonce which can be provided to prove that at least a small amount of work was done; this quick outer PoW verification can be used for anti-DDoS purposes. It also serves to provide statistical assurance that the result is an unbiased, 256-bit number.

The PoW-function returns an array with the compressed mix as its first item and the Keccak-256 hash of the concatenation of the compressed mix with the seed hash as the second item: (352)

$$\text{Poi}(H\_{\mathbf{H}}, H\_{\mathbf{h}}, \mathbf{d}) = \{ \mathbf{m}\_{\text{c}}(\text{KEC}(\mathbf{RLP}(L\_{\mathbf{H}}(H\_{\mathbf{K}}))), H\_{\mathbf{h}}, \mathbf{d}), \text{KEC}(\mathbf{s}\_{\text{h}}(\text{KEC}(\mathbf{RLP}(L\_{\mathbf{H}}(H\_{\mathbf{K}}))), H\_{\mathbf{h}}) + \mathbf{m}\_{\text{c}}(\text{KEC}(\mathbf{RLP}(L\_{\mathbf{H}}(H\_{\mathbf{K}}))), H\_{\mathbf{h}}, \mathbf{d})) \}$$

With Hn being the hash of the header without the nonce. The compressed mix m<sup>c</sup> is obtained as follows:

$$\mathbf{m}\_{\rm c}(\mathbf{h}, \mathbf{n}, \mathbf{d}) = E\_{\rm compness}(E\_{\rm accosses}(\mathbf{d}, \sum\_{i=0}^{n\_{\rm mix}} \mathbf{s\_h}(\mathbf{h}, \mathbf{n}), \mathbf{s\_h}(\mathbf{h}, \mathbf{n}), -1), -4)$$

The seed hash being:

$$\begin{aligned} \text{(354)}\\ \text{(354)} \end{aligned} \text{\text{s} = \text{\textquotedblleft}n, n\text{\textquotedblright} = \text{\textquotedblleft}E \text{\textquotedblright} \mathbf{12} \text{\textquotedblleft}(\mathbf{h} + E\_{\text{revart}}(\mathbf{n})) \end{aligned} \tag{355}$$

Erevert(n) returns the reverted bytes sequence of the nonce n:

$$(355) \tag{355}$$

$$E\_{\text{revar}}(\mathbf{n})[i] = \mathbf{n}[|\mathbf{n}|] - i$$

We note that the "+"-operator between two byte sequences results in the concatenation of both sequences.

The dataset d is obtained as described in section [J.4.3.](#page-40-0)

The number of replicated sequences in the mix is:

$$\begin{aligned} \text{(356)} \qquad \qquad \qquad \qquad \qquad n\_{\text{mlx}} = \left\lfloor \frac{J\_{\text{mlx} \text{bytas}}}{J\_{\text{hashyts}}} \right\rfloor. \end{aligned} $$

In order to add random dataset nodes to the mix, the Eaccesses function is used:

$$\begin{aligned} \text{(357)} \qquad \qquad E\_{\text{accessass}}(\mathbf{d}, \mathbf{m}, \mathbf{s}, i) = \begin{cases} E\_{\text{mix}\text{data}\text{ast}}(\mathbf{d}, \mathbf{m}, \mathbf{s}, i) & \text{if} \quad i = J\_{\text{access}} - 2 \\ E\_{\text{access}}(E\_{\text{mix}\text{data}\text{ast}}(\mathbf{d}, \mathbf{m}, \mathbf{s}, i), \mathbf{s}, i + 1) & \text{otherwise} \end{cases} \end{aligned} $$

$$\begin{array}{cc} \text{(358)} & E\_{\text{mix}\text{data}\text{sat}}\text{(d, m, s, i)} = E\_{\text{FNV}}(\mathbf{m}, E\_{\text{newdata}}(\mathbf{d}, \mathbf{m}, \mathbf{s}, i)) \end{array}$$

Enewdata returns an array with nmix elements:

$$(359)\ E\_{\text{newdata}}(\mathbf{d}, \mathbf{m}, \mathbf{s}, i)[j] = \mathbf{d}[E\_{\text{FNV}}(i \oplus \mathbf{s}[0], \mathbf{m}[i \bmod \left|\frac{J\_{\text{mkhyts}}}{J\_{\text{wordsty}}}\right|)] \bmod \left|\frac{d\_{\text{lka}}/J\_{\text{hankbyts}}}{n\_{\text{mix}}}\right| \cdot n\_{\text{mix}} + j] \quad \forall \ j < n\_{\text{mix}}$$
  $\text{The mix is compressed as follows:}$  
$$(360)\ E\_{\text{compous}}(\mathbf{m}, i) = \begin{cases} \mathbf{m} & \text{if } i \geqslant \|\mathbf{m}\| - 8\\ E\_{\text{compous}}(E\_{\text{FNV}}(E\_{\text{FNV}}(E\_{\text{FNV}}(\mathbf{m}[i + 4], \mathbf{m}[i + 5]), \mathbf{m}[i + 6]), \mathbf{m}[i + 7]), i + 8 \end{cases} \quad \forall \ j = \frac{1}{2}, j \in \{1, 2\}$$

Appendix K. Anomalies on the Main Network

K.1. Deletion of an Account Despite Out-of-gas. At block 2675119, in the transaction 0xcf416c536ec1a19ed1fb89e 4ec7ffb3cf73aa413b3aa9b77d60e4fd81a4296ba, an account at address 0x03 was called and an out-of-gas occurred during the call. Against the equation [\(209\)](#page-21-2), this added 0x03 in the set of touched addresses, and this transaction turned σ[0x03] into ∅.

Appendix L. List of mathematical symbols

<span id="page-41-0"></span>

| Symbol | Latex Command | Description                                                                           |
|--------|---------------|---------------------------------------------------------------------------------------|
| W      | \bigvee       | This is the least upper bound, supremum, or join of all elements operated on. Thus it |
|        |               | is the greatest element of such elements (Davey and Priestley [2002]).                |